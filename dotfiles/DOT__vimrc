"########################################################################################################################
"# zR / zM  = déplier / replier tous les folds
"########################################################################################################################


"# GÉNÉRALITÉS : {{{
"########################################################################################################################

set tabstop=4         " largeur d'affichage des tabulations
set shiftwidth=4      " nombre d'espaces à insérer quand on indente
set expandtab         " forcer l'utilisation des espaces au lieu de tabulations
set textwidth=0       " désactiver la coupure automatique d'une ligne
set mouse=a           " activer la souris (par contre on ne peut-plus copier-coller une sélection à la souris depuis une autre application)
set incsearch         " surbrillance en cours de tapage d'une recherche
set hlsearch          " surbrillance des résultats d'une recherche
set noignorecase      " ignorer la casse dans les recherches :
set tabpagemax=30     " pas plus de tant d'onglets
set bufhidden=delete  " suppression d'un buffer lorsqu'il devient caché :
set breakat=" "       " seuls les espaces 'cassent' des lignes (e.g. pour ne pas splitter une URL)
set foldlevelstart=99 " Tous les folds automatiques sont ouverts par défaut :
set whichwrap=b,s,<,>,[,],h,l  " pouvoir se déplacer d'une ligne à l'autre avec ces touches
set wrap
set backspace=indent,eol,start  " cf. https://vi.stackexchange.com/questions/2162/why-doesnt-the-backspace-key-work-in-insert-mode
set splitbelow
set splitright
set title
set list
set showbreak=↪
set listchars=tab:▶\ ,trail:●,nbsp:␣,precedes:←,extends:→
set redrawtime=10000  " autorise le chargement de syntaxe à prendre plus de temps que les 2s par défaut
set wildignore+=*/tmp/*,*.so,*.o,*.swp,*.zip,*.pyc
set nocompatible
set switchbuf+=usetab,newtab


" Par défaut, on désactive les pair-match facilities, (à réactiver pour les buffers de code).
" (en effet, hors du code, c'est relou de voir se colorer une parenthèse quand je survole sa parente)
let g:loaded_matchparen = 0
set noshowmatch

let g:mapleader = "ç"

" Coloration syntaxique (désactivé pour le mode vimdiff, pour bien voir tous les caractères)
if ! &diff
    syntax on                  " À placer AVANT la ligne filetype
    filetype plugin indent on  " À placer APRÈS la ligne syntax
endif

colorscheme morning
" set Search highlight-group to IncSearch (which I prefer) :
hi! link Search IncSearch

" Better foldline :
" Copied from http://gregsexton.org/2011/03/27/improving-the-text-displayed-in-a-vim-fold.html
" The goal is to see a bigger part of a folded line (particularly useful on OTL files)
function CustomFoldText()
    "get first non-blank line
    let fs = v:foldstart
    while getline(fs) =~ '^\s*$' | let fs = nextnonblank(fs + 1)
    endwhile
    if fs > v:foldend
        let line = getline(v:foldstart)
    else
        let line = substitute(getline(fs), '\t', repeat(' ', &tabstop), 'g')
    endif

    let w = winwidth(0) - &foldcolumn - (&number ? 8 : 0)
    let foldSize = 1 + v:foldend - v:foldstart
    let foldSizeStr = " " . foldSize . " lines "
    let foldLevelStr = repeat("+--", v:foldlevel)
    let lineCount = line("$")
    let foldPercentage = printf("[%.1f", (foldSize*1.0)/lineCount*100) . "%] "
    let expansionString = repeat(".", w - strwidth(foldSizeStr.line.foldLevelStr.foldPercentage))
    return line . expansionString . foldSizeStr . foldPercentage . foldLevelStr
endf
set foldtext=CustomFoldText()

" (généralités) }}}


"# CODE : {{{
"########################################################################################################################

let g:codepatterns = [
            \ '*.html',
            \ '*.css',
            \ '*.py',
            \ '*.js',
            \ '*.ts',
            \ '*.c',
            \ '*.cpp',
            \ '*.h',
            \ '*.hpp',
            \ '*.rb',
            \ '*.sh',
            \ '*.rs'
            \]

for codepattern in g:codepatterns
    execute "autocmd BufEnter " . codepattern . " call CodeSettings()"
endfor

" coloration des type-infos par rust-tools à la fin de la ligne :
highlight RustToolsTypeInfo cterm=bold

function CodeSettings()  " settings spécifiques aux buffers contenant du code
    " Affichage de limites verticales à 120 caractères :
    set colorcolumn=100,120  " possible aussi : 80,100,120
    highlight ColorColumn ctermbg=LightRed ctermfg=Black
    highlight TrailingWhitespace ctermbg=red
    match TrailingWhitespace  /\s\+$/
    set nu

    " Visualiser la position du curseur :
    set cursorline
    set cursorcolumn
    highlight CursorColumn ctermbg=189
    " cf. https://smarttech101.com/how-to-configure-colorscheme-in-vim-neovim
    " cf. https://gist.github.com/vivkin/567896630dbc588ad470b8196c601ad1#file-256-color-table-sh
endfunction

" Coloration des non-breakable spaces :
highlight nbspColor ctermbg=red
call matchadd("nbspColor", " ")

" Compatibilité tmux (cf. https://sunaku.github.io/vim-256color-bce.html), qui nécessite côté tmux :
" set-window-option -g xterm-keys on
" set -g default-terminal "screen-256color"
set t_ut=
redraw

" " buffer HTML => template django => commentaire jinja2 :
" autocmd BufEnter *.html setlocal filetype=htmldjango
" autocmd FileType htmldjango set commentstring={#%s#}

" filetypes spécifiques :
autocmd BufEnter *.Jenkinsfile setlocal filetype=groovy
autocmd BufEnter tsconfig.json setlocal filetype=javascript  " fichier de config typescript

runtime macros/matchit.vim  " permet de switcher entre les tags HTML avec %

" Folding avec les brackets triples {{{ }}} pour l'édition des fichiers vim (y compris le présent fichier) :
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
    autocmd FileType vim setlocal foldlevel=0
augroup END

augroup json
    autocmd FileType json setlocal foldmethod=syntax
augroup END

" Par défaut, on recherche 'tags' jusqu'à la racine :
set tags=tags;/

" Augmenter la taille de la QuickfixList (et la réduire si inutile) :
" cf. http://vim.wikia.com/wiki/Automatically_fitting_a_quickfix_window_height
function! AdjustWindowHeight(minheight, maxheight)
  exe max([min([line("$"), a:maxheight]), a:minheight]) . "wincmd _"
endfunction
autocmd FileType qf call AdjustWindowHeight(3, 40)

" (code) }}}


"# PERSONNALISATION DE LA FENÊTRE {{{
"########################################################################################################################

" Barre de statut (cf. :help statusline) :
set laststatus=2
if has("statusline")
  set statusline=%m       " flag de modification : [+]
  set statusline=\ %F     " chemin du fichier édité
  set statusline+=%r%h%w  " flags RO / help / preview
  set statusline+=%=      " passe de l'autre côté de la ligne
  set statusline+=FT=%y   " filetype
  set statusline+=\ \|\ EOL=%{&fileformat}           " fileformat (ex: python, ou vo_base)
  set statusline+=\ \|\ %{(&fenc==\"\"?&enc:&fenc)}  " encoding
  set statusline+=\ \|\ C=%v                         " colonne actuelle
  set statusline+=\ \|\ L=%l/%L                      " ligne actuelle / lignes totales
endif

" Changement de couleur en mode insertion (help ctermbg) :
if version >= 700
  autocmd InsertEnter * hi StatusLine term=reverse ctermfg=1
  autocmd InsertLeave * hi StatusLine term=reverse ctermfg=0 ctermbg=7
endif

" Coloration des tabulations :
highlight TabulationsColor ctermbg=LightRed
call matchadd("TabulationsColor", "\t")

" Ligne des tabs (cf. :help setting-tabline)
highlight UnsavedTabLine term=underline cterm=underline ctermfg=1 ctermbg=7 gui=underline guibg=LightGrey
highlight UnsavedTabLineSel ctermfg=1 term=bold cterm=bold gui=bold " Copie modifiée de TabLineSel

function MyTabLine()
    let return_string = ''
    for fake_tab_number in range(tabpagenr('$'))
        " Initialisation des variables :
        let tab_number = fake_tab_number + 1
        let buflist = tabpagebuflist(tab_number)
        let win_number = tabpagewinnr(tab_number)
        let buffer_number = buflist[win_number - 1]
        let is_buffer_modified = getbufvar(buffer_number, "&modified")

        " Coloration du tab courant (dépend du fait qu'il soit sélectionné, et qu'il soit modifié) :
        if tab_number == tabpagenr()
            if is_buffer_modified
                let return_string .= '%#UnsavedTabLineSel#'
            else
                let return_string .= '%#TabLineSel#'
            endif
        else
            if is_buffer_modified
                let return_string .= '%#UnsavedTabLine#'
            else
                let return_string .= '%#TabLine#'
            endif
        endif

        " Numéro de l'onglet (pour les clics de souris) :
        let return_string .= '%' . tab_number . 'T'

        " Le titre du tab courant est le nom court du buffer :
        let tab_name = fnamemodify(bufname(buffer_number), ":t")
        if empty(tab_name)
            let tab_name = "*EMPTY*"
        endif
        let return_string .= ' ' . tab_name . ' '
    endfor

    " Complétion de la ligne avec TabLineFill, et reset du tab page number :
    let return_string .= '%#TabLineFill#%T'

    " Ajout du symbole de fermeture, aligné à droite :
    let close_symbol = 'X'
    if tabpagenr('$') > 1
        let return_string .= '%=%#TabLine#%999X' . close_symbol
    endif

    return return_string
endfunction

set tabline=%!MyTabLine()

" (personnalisation de la fenêtre) }}}


"# VIMOUTLINER / VIMDIFF {{{
"########################################################################################################################

function RobustDeleteTabMatch()
    " Suppression de la coloration des tabulations, robuste à l'absence du match :
    for potential_match in getmatches()
        let l:group = potential_match["group"]
        let l:id = potential_match["id"]
        let l:tabcolor = "TabulationsColor"
        " On ne supprime le match que s'il existe :
        if l:group == l:tabcolor
            call matchdelete(l:id)
        endif
    endfor
endfunction

" Options spécifiques à VimOutliner :
autocmd BufEnter *.otl setlocal wrap " Remettre le wrap
autocmd BufEnter *.otl setlocal linebreak " Remettre le linebreak
autocmd BufEnter *.otl call RobustDeleteTabMatch() " Supprimer la coloration des tabulations
autocmd BufEnter *.otl setlocal listchars+=tab:\ \  " ne pas afficher les leading-tabs pour les fichiers OTL
" for whatever reasons, foldtext must be manually set for OTL files...
autocmd BufEnter *.otl setlocal foldtext=CustomFoldText()

" Options spécifiques à vimdiff :
" On colorie toutes les lignes de la même façon = MatchParen :
highlight! link DiffAdd MatchParen
highlight! link DiffDelete MatchParen
highlight! link DiffChange MatchParen
highlight! link DiffText Todo  " dans une ligne, la couleur Todo qui signale le changement

" (vimoutliner/vimdiff) }}}


"# MES ALIAS HORS PLUGINS  {{{
"########################################################################################################################

" ATTENTION : les commandes Alt sont interceptées par tmux (et doivent être
" forwardées avec send-keys dans la config tmux).

" Navigation dans les onglets avec ALT + gauche/droite (EDIT : fonctionne aussi avec gt/gT)
noremap  <A-Right>        :tabn<CR>
inoremap <A-Right>   <Esc>:tabn<CR>
noremap  <A-Left>         :tabp<CR>
inoremap <A-Left>    <Esc>:tabp<CR>

" Défiler l'écran (sans bouger le curseur) avec CTRL + haut/bas
noremap   <C-Down> <C-E>
inoremap  <C-Down> <C-E>
noremap!  <C-Down> <C-X><C-E>
" NOTE : pour C-Y, je dois désactiver le timeout pour ne pas interférer avec emmet.
noremap   <C-Up>   :set notimeout nottimeout<CR><C-Y>:set timeout ttimeout<CR>
inoremap  <C-Up>   <Esc>:set notimeout nottimeout<CR><C-Y>:set timeout ttimeout<CR>i
noremap!  <C-Up>   <C-X><C-Y>

" ouverture d'un tag directement dans un onglet :
" cf.  https://stackoverflow.com/questions/22776092/have-vim-tag-matchlist-open-a-new-tab/22788353#22788353
"     s'il n'y a qu'un match, on l'ouvre dans un tab
"     s'il y a plusieurs matchs, ouvre la matchlist dans un tab
"     ça n'empêche pas d'utiliser C-] / C-t  pour naviguer vers un tag dans la fenêtre courante
" NOTE : autre option = mapper la séquence : C-W + C-]  puis C-W + S-T
nnoremap \| :tab tjump <C-r><C-w><CR>

" Toggle d'options utiles :
noremap <leader><leader>h :set hlsearch!<CR>:set hlsearch?<CR>
noremap <leader><leader>i :set ignorecase!<CR>:set ignorecase?<CR>
noremap <leader><leader>n :set nu!<CR>:set nu?<CR>
noremap! <leader><leader>h <Esc>:set hlsearch!<CR>:set hlsearch?<CR>a
noremap! <leader><leader>i <Esc>:set ignorecase!<CR>:set ignorecase?<CR>a
noremap! <leader><leader>n <Esc>:set nu!<CR>:set nu?<CR>a

" Refresh de la syntaxe :
noremap <leader><leader>syntax :syntax sync fromstart<CR>
noremap! <leader><leader>syntax <Esc>:syntax sync fromstart<CR>a


" récupérer facilement le répertoire racine d'un éventuel projet git :
" cf. https://github.com/mileszs/ack.vim/issues/188#issuecomment-417939294
function! Git_root()
  return system('git rev-parse --show-toplevel 2> /dev/null')[:-2]
endfunction

function! Cat_to_git_root(file)
    " note : a final space is added to facilitate the append of the next text
    return Git_root() . '/' . a:file . ' '
endfunction

" exécution de ctags :
noremap  <F5>              :execute '!ctags -R --exclude=.tox --exclude=.git -f ' . Cat_to_git_root('/tags') . Git_root()<CR>
noremap! <F5>         <Esc>:execute '!ctags -R --exclude=.tox --exclude=.git -f ' . Cat_to_git_root('/tags') . Git_root()<CR>
vnoremap <F5>    <Esc><Esc>:execute '!ctags -R --exclude=.tox --exclude=.git -f ' . Cat_to_git_root('/tags') . Git_root()<CR>
" NOTE : exemples de commandes de génération de tags :
"     apt-get install exuberant-ctags 
"     ctags -R --exclude='.git' --languages=python
"     ctags -R --exclude='.git' --languages=python,js
"     ctags -R --exclude='.git' --languages=python,js -f myspecifictagfile

 " (mes alias hors plugins) }}}


"# PLUGINS {{{
"########################################################################################################################

" disabling polyglot ftdetect, in order for OTL files to properly be detected :
" also disabling it for markdown (I cannot get polyglot's markdown to work with
" vim-markdown-folding, and I value markdown folding more than markdown
" highlighting...) :
let g:polyglot_disabled = ['ftdetect', 'markdown']  " must be set BEFORE polyglot is loaded

autocmd FileType markdown set foldexpr=NestedMarkdownFolds()


let g:vim_search_pulse_color_list = [22, 28, 34, 40, 46]

" :hi pour voir les highlights actuels (avec exemples)
" pour info, valeurs par défaut :
" DiagnosticError xxx ctermfg=1 guifg=Red
" DiagnosticWarn xxx ctermfg=3 guifg=Orange
" DiagnosticInfo xxx ctermfg=4 guifg=LightBlue
" DiagnosticHint xxx ctermfg=7 guifg=LightGrey
hi DiagnosticError cterm=underline,bold ctermfg=1 gui=bold guifg=Red
hi DiagnosticWarn  cterm=underline,bold ctermfg=3 gui=bold guifg=Orange
hi DiagnosticInfo  cterm=underline,bold ctermfg=4 gui=bold guifg=LightBlue
hi DiagnosticHint  cterm=underline,bold ctermfg=0 gui=bold guifg=Black


" (plugins) }}}


"# LUACONFIG {{{
"########################################################################################################################

if has("nvim")

lua << EOF


-- nvim-tree recommande de disabler netrw, cf. :help nvim-tree-netrw
vim.g.loaded_netrw       = 1
vim.g.loaded_netrwPlugin = 1

local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not vim.loop.fs_stat(lazypath) then
  vim.fn.system({
    "git",
    "clone",
    "--filter=blob:none",
    "https://github.com/folke/lazy.nvim.git",
    "--branch=stable", -- latest stable release
    lazypath,
  })
end
vim.opt.rtp:prepend(lazypath)



-- F8 = ouvrir nvim-tree sur le fichier courant :
vim.keymap.set({'n', 'i', 'v'}, '<F8>', ':NvimTreeFindFileToggle<CR>', { noremap = true })

-- S-F8 = ouvrir nvim-tree sur le git-root :
local function get_git_root()
    local dot_git_path = vim.fn.finddir(".git", ".;")
    return vim.fn.fnamemodify(dot_git_path, ":h")
end
-- attention, sous neovim, pour qu'un shortcut S-Fxx marche, il faut utiliser F(xx+12) :
vim.keymap.set({'n', 'i', 'v'}, '<F20>', ':NvimTreeToggle ' .. get_git_root() .. '<CR>', { noremap = true })

-- Ctrl+T pour tabularize :
vim.keymap.set({'v',}, '<C-T>', ':Tabularize /', { noremap = true })

local plugins = {
    {
        -- vim-outliner colors + foldings :
        "https://github.com/vimoutliner/vimoutliner.git",
        ft = 'votl',
    },
    -- file browser :
    {
        "nvim-tree/nvim-tree.lua",
        version = "*",
        lazy = false,
        dependencies = {
            "nvim-tree/nvim-web-devicons",
            },
        config = function()
            require("nvim-tree").setup {
                actions = {
                    open_file = {
                        quit_on_open = true,
                    },
                },
                sort_by = "case_sensitive",
                view = {
                    width = 60,
                },
                renderer = {
                    group_empty = true,
                },
                filters = {
                    dotfiles = true,
                },
            }
        end,
    },

    -- " fuzzy finder of... things (files, tags, LSP symbols, git commits, etc.)
    {
        'nvim-telescope/telescope.nvim',
        tag = '0.1.4',
        dependencies = { 'nvim-lua/plenary.nvim' },
    },

    -- enhances ga to display info on a character, including its digraph code
    {
        'https://github.com/tpope/vim-characterize'
    },

    -- ChatGPT :
    {
        "jackMort/ChatGPT.nvim",
        event = "VeryLazy",
        config = function()
            require("chatgpt").setup()
        end,
        dependencies = {
            "MunifTanjim/nui.nvim",
            "nvim-lua/plenary.nvim",
            "nvim-telescope/telescope.nvim"
        }
    },

    -- align tokens of a line according to a separator :
    {
        "https://github.com/godlygeek/tabular.git",
        cmd = "Tabularize",
    },

    -- surround :
    {
        "https://github.com/tpope/vim-surround.git",
    },

    -- repeat a surrounding command
    {
        "https://github.com/tpope/vim-repeat",
    },

    -- comment :
    {
        'numToStr/Comment.nvim',
        config = function()
            require('Comment').setup()
        end,
    },

    -- language pack :
    {
        'https://github.com/sheerun/vim-polyglot',
    },

    -- indentline :
    {
        "lukas-reineke/indent-blankline.nvim",
        main = "ibl",
        opts = {},
        config = function()
            require("ibl").setup {
                indent = { highlight = { "Normal" } },
                whitespace = { highlight = { "Normal" } },
            }
        end,
    },

    -- markdown-folding :
    {
        "https://github.com/masukomi/vim-markdown-folding",
    },

    -- make searched line pulse briefly to ease visualization
    {
        "https://github.com/inside/vim-search-pulse",
    },

    -- smooth scrolling (to ease visualizing Ctrl-down/Ctrl-up)
    {
        "karb94/neoscroll.nvim",
      config = function ()
          require('neoscroll').setup {}
      end
    },

    -- nvim LSP config :
    {
        "https://github.com/neovim/nvim-lspconfig",
    },

    -- running generic tools as LSP servers
    {
        "https://github.com/jose-elias-alvarez/null-ls.nvim",
    },

    -- rust-tools :
    {
        "https://github.com/simrat39/rust-tools.nvim",
    },


    -- highlight same words as the one under cursor
    -- note : pour visualiser dynamiquement les highlights groups :
    --   :so $VIMRUNTIME/syntax/hitest.vim
    {
        'tzachar/local-highlight.nvim',
        config = function()
            require('local-highlight').setup({
                file_types = {'python', 'cpp', 'rust'},
                hlgroup = 'CursorColumn',
                insert_mode = false,
            })
        end
    },

    -- auto cd to git root dir :
    {
        "ahmedkhalf/project.nvim",
        config = function()
            require('project_nvim').setup {}
        end,
    },

    -- justfile syntax
    {
        "https://github.com/NoahTheDuke/vim-just",
    },
}

require("lazy").setup(plugins, opts)


-- if needed, see https://github.com/nanotee/nvim-lua-guide
-- (notably : each :lua command has its own scope)

-- -- plugin init :
-- require('nvim_comment').setup{}
-- require("project_nvim").setup{}


-- See `:help vim.diagnostic.*` for documentation on any of the below functions
-- native LSP client

local opts = { noremap=true, silent=true }
vim.keymap.set('n', '<A-k>', vim.diagnostic.goto_prev, opts)
vim.keymap.set('n', '<A-j>', vim.diagnostic.goto_next, opts)

-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
local on_attach = function(client, bufnr)
  -- Enable completion triggered by <c-x><c-o>
  vim.api.nvim_buf_set_option(bufnr, 'omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- Mappings.
  -- See `:help vim.lsp.*` for documentation on any of the below functions
  local bufopts = { noremap=true, silent=true, buffer=bufnr }

  vim.keymap.set({'n', 'i', 'v'}, '<F12>', vim.lsp.buf.definition, bufopts)  -- F12 = go to definition in the same tab
  vim.keymap.set({'n', 'i', 'v'}, 'g<F12>', '<ESC><cmd>tab split<CR><cmd>lua vim.lsp.buf.definition()<CR>', bufopts)  -- g-F12 = go to definition in a new tab
  -- to make S-Fxx work in neovim, I have to use Fyy where yy = xx + 12 :
  vim.keymap.set({'n', 'i', 'v'}, '<F24>', vim.lsp.buf.references, bufopts)  -- Shift-F12 = who uses this symbol ?
  vim.keymap.set({'n', 'v'}, 'gh', vim.lsp.buf.hover, bufopts)
  vim.keymap.set({'n', 'v'}, 'gb', vim.lsp.buf.code_action, bufopts)  -- gc (pour [C]ode-actions) et ga (pour code-[A]ctions) sont déjà pris...
  vim.keymap.set('n', '==', vim.lsp.buf.formatting, bufopts)
  vim.keymap.set('v', '=', '<ESC><cmd>lua vim.lsp.buf.range_formatting()<CR>', bufopts)


  -- NdM : rename = besoin suffisamment rare pour ne pas ajouter de mapping :
  -- un alias me permettra de compléter la commande plus facilement
  -- (et par cohérence, j'ajoute les autres alias) :
  -- Exemple d'utilisation (il va demander le nouveau nom) :
  --
  --      :lua lsp_rename()
  --
  lsp_rename = vim.lsp.buf.rename
  lsp_references = vim.lsp.buf.references
  lsp_definition = vim.lsp.buf.definition
  lsp_hover = vim.lsp.buf.hover
  lsp_formatting = vim.lsp.buf.hover

  -- NdM : pas encore essayé :
  -- vim.keymap.set('n', '<space>ca', vim.lsp.buf.code_action, bufopts)

  -- NdM : moins utile que 'definition' :
  -- vim.keymap.set({'n', 'i', 'v'}, '<F12>', vim.lsp.buf.declaration, bufopts)

  -- NdM : non-pris en charge par clangd et/ou pyright :
  -- vim.keymap.set({'n', 'i', 'v'}, '<F12>', vim.lsp.buf.type_definition, bufopts)
  -- vim.keymap.set({'n', 'i', 'v'}, '<F12>', vim.lsp.buf.implementation, bufopts)

  -- toggling diagnostics (there is no native function for that) :
  -- inspired by https://www.reddit.com/r/neovim/comments/ng0dj0/lsp_diagnostics_query_is_there_an_way_to_toggle/
  vim.g.diagnostics_active = true
  function _G.toggle_diagnostics()
    if vim.g.diagnostics_active then
      print('disabling diagnostics...')
      vim.g.diagnostics_active = false
      vim.diagnostic.disable()
    else
      print('enabling diagnostics...')
      vim.g.diagnostics_active = true
      vim.diagnostic.enable()
    end
  end
  -- gt sert normalement à switcher de tab, mais je n'utilise pas -> g[T]oggle :
  vim.keymap.set({'n', 'v'}, 'gt', _G.toggle_diagnostics, bufopts)

end

require('lspconfig')['pyright'].setup{
    on_attach = on_attach,
    flags = lsp_flags,
}
require('lspconfig')['clangd'].setup{
    on_attach = on_attach,
    flags = lsp_flags,
}
require('lspconfig')['tsserver'].setup{
    on_attach = on_attach,
    flags = lsp_flags,
}
require('rust-tools').setup{
    server = {on_attach = on_attach},
    flags = lsp_flags,
    tools = {inlay_hints = {
        max_len_align = true,
        highlight= "RustToolsTypeInfo",
        }
    },
}

-- null-lsp :
local null_ls = require("null-ls")
local sources = {
    null_ls.builtins.diagnostics.flake8.with({extra_args = {"--max-line-length","120"}}),
}
null_ls.setup({ sources = sources })



-- telescope :
-- Ctrl+p already use in vscode : https://linuxpip.org/vscode-find-file/
vim.keymap.set({'n', 'i', 'v'}, '<C-p>', require('telescope.builtin').find_files, bufopts)
-- vscode shortcut to search symbols is C-t ; as it's not available in vim, I use C-A-t :
vim.keymap.set({'n', 'i', 'v'}, '<C-A-t>', require('telescope.builtin').lsp_dynamic_workspace_symbols, bufopts)
-- https://code.visualstudio.com/docs/editor/codebasics#_search-across-files
-- vscode shortcut to search text is C-S-f ; as it's not available in vim, I use C-A-g :
vim.keymap.set({'n', 'i', 'v'}, '<C-A-g>', require('telescope.builtin').live_grep, bufopts)


-- always show error columns :
vim.api.nvim_set_option('signcolumn', 'auto:1-3')


EOF

endif  " has("nvim")

" (luaconfig) }}}


"# DEPRECATED {{{
"########################################################################################################################

" plugins un jour utilisés, aujourd'hui abandonnés :
" https://github.com/elzr/vim-json
" " Ne pas masquer les guillemets en json :
" let g:vim_json_syntax_conceal = 0
" https://github.com/LucHermitte/local_vimrc
" https://github.com/LucHermitte/lh-vim-lib
" https://github.com/tmhedberg/SimpylFold
" https://github.com/jlanzarotta/bufexplorer
" Plug 'https://github.com/rking/ag.vim'
" Plug 'https://github.com/airblade/vim-rooter'
" Plug 'https://github.com/integralist/vim-mypy', {'for': 'python' }
" Plug 'https://github.com/chr4/nginx.vim'
" Plug 'https://github.com/plasticboy/vim-markdown', {'for': 'markdown'}
" Plug 'https://github.com/habamax/vim-asciidoctor', {'for': 'asciidoc'}
" Plug 'https://github.com/tpope/vim-commentary.git'


" flake8 est dorénavant directement utilisé via ALE
" Plug 'https://github.com/nvie/vim-flake8', {'for': 'python' }
" let g:flake8_quickfix_height=3
" let g:flake8_show_quickfix=0
" let g:flake8_show_in_file=1
" let g:flake8_show_in_gutter=1
" autocmd BufWritePost *.py call Flake8()  " lancement automatique au save de fichiers python
" " effacer les marqueurs flake8 avec F11:
" noremap <F11>             :call flake8#Flake8UnplaceMarkers()<CR>
" noremap! <F11>       <Esc>:call flake8#Flake8UnplaceMarkers()<CR>
" vnoremap <F11>  <Esc><Esc>:call flake8#Flake8UnplaceMarkers()<CR>


" J'ai remplacé ALE par le client LSP natif à neovim :
" " LSP client
" Plug 'https://github.com/dense-analysis/ale'
" let g:ale_default_navigation = 'tab'
" let g:ale_completion_enabled = 1
" " NOTE : pour les shortcuts, autant que possible, j'ai repris ceux de vscode :
" " https://code.visualstudio.com/docs/editor/editingevolved
" " https://marketplace.visualstudio.com/items?itemName=ryzngard.vscode-header-source
" noremap gh                :ALEHover<CR>

" noremap <F12>             :ALEGoToDefinition<CR>
" noremap! <F12>       <Esc>:ALEGoToDefinition<CR>
" vnoremap <F12>  <Esc><Esc>:ALEGoToDefinition<CR>

" noremap  <A-j>            :ALENextWrap<CR>
" noremap! <A-j>       <Esc>:ALENextWrap<CR>a
" vnoremap <A-j>  <Esc><Esc>:ALENextWrap<CR>

" noremap  <A-k>            :ALEPreviousWrap<CR>
" noremap! <A-k>       <Esc>:ALEPreviousWrap<CR>a
" vnoremap <A-k>  <Esc><Esc>:ALEPreviousWrap<CR>

" if has("nvim")
"     " to make S-Fxx work in neovim, I have to use Fyy where yy = xx + 12 :
"     noremap <F24>               :ALEFindReferences<CR>
"     noremap! <F24>         <Esc>:ALEFindReferences<CR>
"     vnoremap <F24>    <Esc><Esc>:ALEFindReferences<CR>
" else
"     noremap <S-F12>               :ALEFindReferences<CR>
"     noremap! <S-F12>         <Esc>:ALEFindReferences<CR>
"     vnoremap <S-F12>    <Esc><Esc>:ALEFindReferences<CR>
" endif

" " Quelques commandes non-mappées car trop peu souvent utiles :
" " :ALESymbolSearch
" " :ALEInfo
" " :ALEDetail

" clang-format semble maintenant appliqué par clangd :
" " use clang-format to format code
" Plug 'https://github.com/kana/vim-operator-user', {'for': 'cpp'}  " pour utiliser vim-clang-format avec '='
" Plug 'https://github.com/rhysd/vim-clang-format', {'for': 'cpp'}
" " (note : ça ne marche pas avec splitjoin, qui semble utiliser le formattage C++ par défaut)
" " (contournement = réappliquer manuellement l'opérateur '=' après avoir utilisé splitjoin)
" autocmd FileType c,cpp map <buffer> = <Plug>(operator-clang-format)
" let g:clang_format#command = 'clang-format-11'


" " fuzzy file opener (NdM : remplacé par telescope)
" Plug 'https://github.com/kien/ctrlp.vim'
" " :help ctrlp-options
" let g:ctrlp_show_hidden = 0  " notably, ignore hidden dirs such as .tox or .clangd
" let g:ctrlp_custom_ignore = '\vNOGIT|__pycache__'


" " no need for a plugin to fold markdown :
" " (EDIT : actually, it is confused by comments in code blocks...)
" let g:markdown_folding = 1


" " integration with ack (or actually ag)
" Plug 'https://github.com/mileszs/ack.vim'
" let g:ackprg = 'ag --vimgrep --smart-case'
" " recherche dans tout le projet git :
" command! -nargs=1 Ag execute "Ack! <args> " . Git_root()
" " recherche dans le même répertoire que le fichier courant :
" command! -nargs=1 AgLocal  execute "Ack! <args> " . expand("%:p:h")
" cnoreabbrev Agl AgLocal
" " TODO : permettre une recherche case-sensitive / case-insensitive ?


" Ctrl+r prépare à insérer le contenu de... quelque chose (registre, mot sous le curseur, etc.) :
" :help C-r
"
" Ctrl+r suivi de " insère le registre anonyme
" peut-être utilisé dans un mapping, permettant par exemple en visualmode de récupérer la sélection avec :
" vnoremap <leader>echoselection  y:echo '<C-R>"'<CR>
" EXPLICATION :
"    le "y" yanke la sélection (et le place donc dans le registre anonyme ")
"    le <C-R>"  utilise le contenu du registre anonyme
"
" Ctrl+r suivi de <C-w> insère le mot sous le curseur :
"    noremap <leader>pouet  y:echo '<C-R>"'<CR>
" c'est très pratique même manuellement : pour rechercher le mot sous le curseur, je peux taper moi-même :
"     :Ag <C-r> <C-w>
" <cword> est une variable qui représente le word sous le curseur :-o

" indenter la sélection visuelle conserve celle-ci (au lieu de la déselectionner) :
" EDIT 2021-12-02 : finalement, je préfère le comportement normal -> je
" commente en attendant de confirmer, et je supprimerai si besoin...
" vnoremap < <gv
" vnoremap > >gv
" vnoremap = =gv

" (deprecated) }}}


function CheatsheetFunction()
    let mycheatsheet  = [
        \ "",
        \ "Pour afficher cette cheatsheet :   CTRL+h  /  :Cheat  /  :call CheatsheetFunction()",
        \ "",
        \ "======= SEARCH :",
        \ "    :copen / :ccl[ose]     ouvrir / fermer la quickfix list",
        \ "    F8                     ouvrir nvim-tree sur le répertoire courant",
        \ "    S-F8                   ouvrir nvim-tree sur le git-root",
        \ "      ├─ g?                 afficher les commandes",
        \ "      ├─ q                  fermer nvim-tree",
        \ "      ├─ Entrée             ouvrir le fichier sélectionné dans le buffer courant",
        \ "      ├─ C-t / C-x / C-h    ouvrir le fichier sélectionné dans un nouveau tab / vsplit / hsplit",
        \ "      ├─ o                  ouvrir/fermer un répertoire",
        \ "      ├─ H                  toggle l'affichage des fichiers cachés",
        \ "      ├─ a / r / d          ajouter / renommer / supprimer un fichier",
        \ "      ├─ y  /  gy           copier le nom / le chemin complet du fichier",
        \ "      └─ -  /  P            remonter d'un cran dans la hiérarchie / se déplacer sur le répertoire parent",
        \ "    F9                     ouvrir la tagbar du fichier courant",
        \ "      ├─ q                  fermer la tagbar",
        \ "      ├─ o                  plier/déplier un folding de la tagbar",
        \ "      ├─ Entrée             sauter sur le tag, et fermer la tagbar",
        \ "      └─ p                  afficher le tag, mais garder le curseur sur la tagbar",
        \ "",
        \ "======= LAZY.NVIM :",
        \ "    https://github.com/folke/lazy.nvim",
        \ "      └─ :Lazy check        afficher l'UI de gestion de lazy.nvim (qui donne accès à toutes les commandes)",
        \ "",
        \ "======= DEV :",
        \ "    CTRL-o / CTRL-i        jumper à un emplacement précédent / suivant du curseur",
        \ "    :help tags",
        \ "      ├─build tags :",
        \ "      │   apt install exuberant-ctags",
        \ "      │   ctags --recurse --c++-kinds=+p --fields=+iaS --extras=+q .",
        \ "      ├─CTRL+]              jumper à la définition du tag",
        \ "      ├─CTRL+t              revenir à l'emplacement précédent",
        \ "      ├─g puis CTRL+]       choisir la destination du jump dans une liste",
        \ "      └─vim -t pouet        ouvrim vim sur le fichier + à l'emplacement du tag 'pouet'",
        \ "    LSP",
        \ "      ├─ F12                 go to definition",
        \ "      ├─ Shift+F12           see references",
        \ "      ├─ gh                  infos sur le symbole courant dans une bulle hover",
        \ "      ├─ Alt+j / Alt+k       go to next/previous error",
        \ "      ├─ :LspStop/Start      (dés)activer le LSP client (semble mal marcher avec null-ls...)",
        \ "      ├─ :LspInfo            des infos sur la config des LSP (e.g. quels linters sont actifs)",
        \ "      ├─ gt                  toggle les diagnostics LSP",
        \ "      └─ CTRL+x CTRL+o       complétion intelligente respectant le contexte via LSP",
        \ "    CTRL+n                 complétion 'dumb'",
        \ "    Telescope",
        \ "      ├─ CTRL-n / CTRL-p     naviguer dans les matchs en mode insertion",
        \ "      ├─ Entrée / CTRL-t     ouvrir le match dans l'onglet courant / un nouvel onglet",
        \ "      ├─ CTRL+/  ou  ?       aide sur les shortcuts de telescope (insert-mode ou normal-mode)",
        \ "      ├─ CTRL+ALT+g          live_grep dans le répertoire courant",
        \ "      ├─ CTRL+ALT+t          rechercher des noms de symboles dans l'index LSP",
        \ "      └─ CTRL+p              fuzzy search files by name (telescope)",
        \ "    Alt-o                  alterner entre .h / .cpp",
        \ "    :AT                    alterner entre .h / .cpp dans un nouvel onglet",
        \ "    CTRL-y + ,             lancer emmet (pour tags HTML faciles)",
        \ "    CTRL-t + <sep>         (visual) tabularize avec des colonnes séparées par <sep>",
        \ "    :IndentLinesToggle     toggle le marqueur des indentations python",
        \ "    :gJ  /  gS             split/join les arguments d'une fonction, placer curseur sur parenthèse ouvrante",
        \ "    == / (visual)=         reformatter tout le fichier (ou uniquement la sélection visuelle)",
        \ "",
        \ "======= MES ALIAS PERSOS (hors plugins) :",
        \ "    CTRL-HAUT/BAS          scroller une ligne vers le bas/haut",
        \ "    ALT-DROITE/GAUCHE      :tabNext / :tabPrev  (EDIT : également commandes natives : gt/gT)",
        \ "    ççh                    toggle hlsearch",
        \ "    ççi                    toggle ignorecase",
        \ "    ççn                    toggle line numbers",
        \ "    ççsyntax               refresh la syntaxe",
        \ "    F5                     lancement de ctags sur le git-root-dir",
        \ "    |                      ouvrir le tag dans un onglet (ou sinon : C-w + C-]  puis C-w + S-T)",
        \ "",
        \ "======= OTHER CORE VIM FEATURES :",
        \ "    :help fold",
        \ "      ├─:set foldlevel=3    setter le foldlevel",
        \ "      ├─zO / zC             ouvrir/fermer le fold actuel et tous ses fils",
        \ "      ├─zr / zm             ouvrir/fermer un niveau de fold supplémentaire",
        \ "      └─zR / zM             ouvrir/fermer TOUS les folds du fichier (utile dans vimdiff)",
        \ "    vimdiff file1 file2",
        \ "      ├─dp                  [P]ut the diff to other file",
        \ "      ├─do                  [O]btain the diff from other file",
        \ "      ├─:diffupdate         refresh diff",
        \ "      ├─CTRL-w + w          mettre le curseur sur l'autre fichier",
        \ "      └─zR / zM             afficher/masquer les portions identiques du fichier",
        \ "    :help split",
        \ "      ├─CTRL-w + _          maximiser le split courant",
        \ "      ├─CTRL-w + =          égaliser les splits",
        \ "      ├─:res[ize] 15        setter la taille du split à 15",
        \ "      ├─:res[ize] +3        augmenter la taille du split de 3 (également CTRL-w - 3+)",
        \ "      ├─CTRL-w + w          déplacer le focus sur un autre split",
        \ "      └─CTRL-w + CTRL-r     swapper les splits",
        \ "    :help C-r",
        \ "      ├─CTRL-r + REG        insère le contenu du registre REG (\" pour le registre anonyme)",
        \ "      ├─CTRL-r + /          insère le pattern de recherche",
        \ "      └─CTRL-r + CTRL-w     insère le mot sous le curseur",
        \ "    :norm! @a              applique la macro 'a' (à utiliser sur un groupe de lignes)",
        \ "    :set conceallevel=0    ne pas masquer de texte (e.g. markdown)",
        \ "    :echo mapleader        afficher le <leader> actuel",
        \ "    :map STRING            afficher les mappings commençant par STRING -> doc de mes raccourcis !",
        \ "    :map <leader>          afficher les mappings commençant par <leader> (marche aussi avec p.ex. <F5>)",
        \ "    ma / 'a                définir la / sauter vers la marque <a>",
        \ "    ''                     après avoir sauté vers une marque, '' permet de revenir là où on était",
        \ "",
        \ "    ... to be continued ...",
        \ "",
        \ ]
    tabnew mycheatsheet
    call append(0, mycheatsheet)
    call cursor(1, 1)
endfunction

command Cheat call CheatsheetFunction()
command Cheatsheet call CheatsheetFunction()
noremap <C-h>             :Cheat<CR>
noremap! <C-h>       <Esc>:Cheat<CR>
vnoremap <C-h>  <Esc><Esc>:Cheat<CR>
