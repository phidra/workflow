"########################################################################################################################
"# zR / zM  = d√©plier / replier tous les folds
"# :set foldlevel=1
"########################################################################################################################

" READING GUIDELINE : la config est splitt√©e en deux sections :
"   - une section en vimscript pour les situations basiques
"   - une section en lua, utile pour les situations poweruser (e.g. coding)
"
" L'id√©e est que la config lua a vocation √† n'√™tre utilis√©e qu'avec neovim sur mes postes de travail,
" alors que la config vimscript peut √™tre utilis√©e avec un vim vanilla, depuis n'importe o√π.

if 1  " cet if inutile est l√† pour homog√©n√©iser les foldings entre les deux sections

function VIM_SECTION_GENERAL()

    set tabstop=4         " largeur d'affichage des tabulations
    set shiftwidth=4      " nombre d'espaces √† ins√©rer quand on indente
    set expandtab         " forcer l'utilisation des espaces au lieu de tabulations
    set textwidth=0       " d√©sactiver la coupure automatique d'une ligne
    set mouse=a           " activer la souris (par contre on ne peut-plus copier-coller une s√©lection √† la souris depuis une autre application)
    set incsearch         " surbrillance en cours de tapage d'une recherche
    set hlsearch          " surbrillance des r√©sultats d'une recherche
    set noignorecase      " ignorer la casse dans les recherches :
    set tabpagemax=30     " pas plus de tant d'onglets
    set bufhidden=delete  " suppression d'un buffer lorsqu'il devient cach√© :
    set breakat=" "       " seuls les espaces 'cassent' des lignes (e.g. pour ne pas splitter une URL)
    set foldlevelstart=99 " Tous les folds automatiques sont ouverts par d√©faut :
    set whichwrap=b,s,<,>,[,],h,l  " pouvoir se d√©placer d'une ligne √† l'autre avec ces touches
    set wrap
    set backspace=indent,eol,start  " cf. https://vi.stackexchange.com/questions/2162/why-doesnt-the-backspace-key-work-in-insert-mode
    set splitbelow
    set splitright
    set title
    set list
    set showbreak=‚Ü™
    set listchars=tab:‚ñ∂\ ,trail:‚óè,nbsp:‚ê£,precedes:‚Üê,extends:‚Üí
    set redrawtime=10000  " autorise le chargement de syntaxe √† prendre plus de temps que les 2s par d√©faut
    set wildignore+=*/tmp/*,*.so,*.o,*.swp,*.zip,*.pyc
    set nocompatible
    set switchbuf+=usetab,newtab


    " Par d√©faut, on d√©sactive les pair-match facilities, (√† r√©activer pour les buffers de code).
    " (en effet, hors du code, c'est relou de voir se colorer une parenth√®se quand je survole sa parente)
    let g:loaded_matchparen = 0
    set noshowmatch

    let g:mapleader = "√ß"

    " Coloration syntaxique (d√©sactiv√© pour le mode vimdiff, pour bien voir tous les caract√®res)
    if ! &diff
        syntax on                  " √Ä placer AVANT la ligne filetype
        filetype plugin indent on  " √Ä placer APR√àS la ligne syntax
    endif

    " set Search highlight-group to IncSearch (which I prefer) :
    hi! link Search IncSearch

    " Better foldline :
    " Copied from http://gregsexton.org/2011/03/27/improving-the-text-displayed-in-a-vim-fold.html
    " The goal is to see a bigger part of a folded line (particularly useful on OTL files)
    function CustomFoldText()
        "get first non-blank line
        let fs = v:foldstart
        while getline(fs) =~ '^\s*$' | let fs = nextnonblank(fs + 1)
        endwhile
        if fs > v:foldend
            let line = getline(v:foldstart)
        else
            let line = substitute(getline(fs), '\t', repeat(' ', &tabstop), 'g')
        endif

        let w = winwidth(0) - &foldcolumn - (&number ? 8 : 0)
        let foldSize = 1 + v:foldend - v:foldstart
        let foldSizeStr = " " . foldSize . " lines "
        let foldLevelStr = repeat("+--", v:foldlevel)
        let lineCount = line("$")
        let foldPercentage = printf("[%.1f", (foldSize*1.0)/lineCount*100) . "%] "
        let expansionString = repeat(".", w - strwidth(foldSizeStr.line.foldLevelStr.foldPercentage))
        return line . expansionString . foldSizeStr . foldPercentage . foldLevelStr
    endf  " CustomFoldText

    autocmd BufEnter * setlocal foldtext=CustomFoldText()

    " toujours utiliser les tabs ; c'est un √©quivalent de "nvim -p", qui fonctionne mal avec carapace-bin
    au VimEnter * if !&diff | tab all | tabfirst | endif


endf  " VIM_SECTION_GENERAL
call VIM_SECTION_GENERAL()


function VIM_SECTION_TABS_AND_STATUSLINE()
    " Barre de statut pour vim uniquement : la statusline neovim est g√©r√©e par un plugin
    " (cf. :help statusline) :
    if ! has("nvim")  " sous neovim, on laisse les plugins g√©rer la statusline
        set laststatus=2
        if has("statusline")
          set statusline=%m       " flag de modification : [+]
          set statusline=\ %F     " chemin du fichier √©dit√©
          set statusline+=%r%h%w  " flags RO / help / preview
          set statusline+=%=      " passe de l'autre c√¥t√© de la ligne
          set statusline+=FT=%y   " filetype
          set statusline+=\ \|\ EOL=%{&fileformat}           " fileformat (ex: python, ou vo_base)
          set statusline+=\ \|\ %{(&fenc==\"\"?&enc:&fenc)}  " encoding
          set statusline+=\ \|\ C=%v                         " colonne actuelle
          set statusline+=\ \|\ L=%l/%L                      " ligne actuelle / lignes totales
        endif

        " Changement de couleur en mode insertion (help ctermbg) :
        if version >= 700
          autocmd InsertEnter * hi StatusLine term=reverse ctermfg=1
          autocmd InsertLeave * hi StatusLine term=reverse ctermfg=0 ctermbg=7
        endif
    endif  " has("nvim")

    " Ligne des tabs (cf. :help setting-tabline)
    function MyTabLine()
        let return_string = ''
        for fake_tab_number in range(tabpagenr('$'))
        " Initialisation des variables :
        let tab_number = fake_tab_number + 1
        let buflist = tabpagebuflist(tab_number)
        let win_number = tabpagewinnr(tab_number)
        let buffer_number = buflist[win_number - 1]
        let is_buffer_modified = getbufvar(buffer_number, "&modified")

        " Coloration du tab courant (d√©pend du fait qu'il soit s√©lectionn√©, et qu'il soit modifi√©) :
        if tab_number == tabpagenr()
            if is_buffer_modified
                let return_string .= '%#DiffChange#'
            else
                let return_string .= '%#TabLineSel#'
            endif
        else
            if is_buffer_modified
                let return_string .= '%#TermCursor#'
            else
                let return_string .= '%#TabLine#'
            endif
        endif

        " Num√©ro de l'onglet (pour les clics de souris) :
        let return_string .= '%' . tab_number . 'T'

        " Le titre du tab courant est le nom court du buffer :
        let tab_name = fnamemodify(bufname(buffer_number), ":t")
        if empty(tab_name)
            let tab_name = "*EMPTY*"
        endif

        if is_buffer_modified
            " rendre les tabs modifi√©s *tr√®s* visibles :
            let return_string .= '   !!!' . tab_name . '!!!   '
        else
            let return_string .= ' ' . tab_name . ' '
        endif

        endfor

        " Compl√©tion de la ligne avec TabLineFill, et reset du tab page number :
        let return_string .= '%#TabLineFill#%T'

        " Ajout du symbole de fermeture, align√© √† droite :
        let close_symbol = 'X'
        if tabpagenr('$') > 1
            let return_string .= '%=%#TabLine#%999X' . close_symbol
        endif

        return return_string
    endfunction

    set tabline=%!MyTabLine()
endf  " VIM_SECTION_TABS_AND_STATUSLINE
call VIM_SECTION_TABS_AND_STATUSLINE()



function VIM_MES_ALIAS_HORS_PLUGINS()
    " ATTENTION : les commandes Alt sont intercept√©es par tmux (et doivent √™tre
    " forward√©es avec send-keys dans la config tmux).

    " Navigation dans les onglets avec ALT + gauche/droite (EDIT : fonctionne aussi avec gt/gT)
    noremap  <A-Right>        :tabn<CR>
    inoremap <A-Right>   <Esc>:tabn<CR>
    noremap  <A-Left>         :tabp<CR>
    inoremap <A-Left>    <Esc>:tabp<CR>

    " D√©filer l'√©cran (sans bouger le curseur) avec CTRL + haut/bas
    noremap   <C-Down> <C-E>
    inoremap  <C-Down> <C-E>
    noremap!  <C-Down> <C-X><C-E>
    " NOTE : pour C-Y, je dois d√©sactiver le timeout pour ne pas interf√©rer avec emmet.
    noremap   <C-Up>   :set notimeout nottimeout<CR><C-Y>:set timeout ttimeout<CR>
    inoremap  <C-Up>   <Esc>:set notimeout nottimeout<CR><C-Y>:set timeout ttimeout<CR>i
    noremap!  <C-Up>   <C-X><C-Y>

    " Toggle d'options utiles :
    noremap <leader><leader>h :set hlsearch!<CR>:set hlsearch?<CR>
    noremap <leader><leader>i :set ignorecase!<CR>:set ignorecase?<CR>
    noremap <leader><leader>n :set nu!<CR>:set nu?<CR>
    noremap! <leader><leader>h <Esc>:set hlsearch!<CR>:set hlsearch?<CR>a
    noremap! <leader><leader>i <Esc>:set ignorecase!<CR>:set ignorecase?<CR>a
    noremap! <leader><leader>n <Esc>:set nu!<CR>:set nu?<CR>a

    " Refresh de la syntaxe :
    noremap <leader><leader>syntax :syntax sync fromstart<CR>
    noremap! <leader><leader>syntax <Esc>:syntax sync fromstart<CR>a
endf  " VIM_MES_ALIAS_HORS_PLUGINS
call VIM_MES_ALIAS_HORS_PLUGINS()

endif  " if 1

"========================================================================================================================
" ^ ci-dessus, la config en vimscript
"
" v ci-dessous, la config en lua
"========================================================================================================================


if has("nvim")
lua << EOF
--  cf. https://neovim.io/doc/user/lua-guide.html


function NEOVIM_SECTION_CODE_SETTINGS()
    -- settings sp√©cifiques aux buffers contenant du code :
    local code_patterns = {
        '*.html',
        '*.css',
        '*.py',
        '*.js',
        '*.json',
        '*.ts',
        '*.c',
        '*.cpp',
        '*.h',
        '*.hpp',
        '*.rb',
        '*.sh',
        '*.Jenkinsfile',
        '*.rs'
    }
    vim.api.nvim_create_autocmd({"BufEnter"}, {
        pattern = code_patterns,
        callback = function ()
            -- limites verticales √† 120 caract√®res :
            vim.opt.colorcolumn = {100, 120}
            vim.cmd.highlight({"ColorColumn", "ctermbg=LightRed", "ctermfg=Black"})

            -- position du curseur :
            vim.opt.cursorline = true
            vim.opt.cursorcolumn = true
            vim.cmd.highlight({"CursorColumn", "ctermbg=250"})
            vim.cmd.highlight({"CursorLine", "ctermbg=250"})
            -- cf. https://smarttech101.com/how-to-configure-colorscheme-in-vim-neovim
            -- cf. https://gist.github.com/vivkin/567896630dbc588ad470b8196c601ad1#file-256-color-table-sh

            -- trailing whitespaces + nbsp + tabulations :
            vim.cmd.highlight({"TrailingWhitespace", "ctermbg=red"})
            vim.cmd.match({"TrailingWhitespace", [[/\s\+$/]]})
            vim.cmd.highlight({"nbspColor", "ctermbg=red"})
            vim.fn.matchadd("nbspColor", "¬†")
            vim.cmd.highlight({"TabulationsColor", "ctermbg=red"})
            vim.fn.matchadd("TabulationsColor", "	")

            -- num√©ros de lignes :
            vim.opt.nu = true;
        end,
    })
    local has_already_reedited_the_buffer_to_work_around_treesitter_bug = false
    vim.api.nvim_create_autocmd({"BufReadPost"}, {
        pattern = code_patterns,
        callback = function ()
            -- on force un `edit` sur les buffers de code (pour contourner le bug treesitter) en triggant
            -- manuellement le d√©clenchement des clients LSP (cf. mes notes dans le plugin treesitter)
            -- NOTE : trigger l'edit imm√©diatement ne fonctionne pas ; je sette donc un d√©lai, ajust√© exp√©rimentalement...
            -- (c'est vraiment hacky, beurk)
            -- En dernier recours, refaire ":e" manuellement.
            vim.defer_fn(function()
                if not has_already_reedited_the_buffer_to_work_around_treesitter_bug  -- ensure only called once
                then
                    has_already_reedited_the_buffer_to_work_around_treesitter_bug = true
                    vim.cmd.edit()
                end
            end, 200)
        end,
    })

    -- utiliser les foldings sur un fichier XML :
    vim.g.xml_syntax_folding = 1
    vim.api.nvim_command('autocmd FileType xml setlocal foldmethod=syntax')

    -- always show error columns :
    vim.api.nvim_set_option('signcolumn', 'auto:1-3')
    vim.cmd.highlight({"SignColumn", "ctermbg=Grey"})

    -- coloration des type-infos par rust-tools √† la fin de la ligne :
    vim.cmd.highlight({"RustToolsTypeInfo", "cterm=bold"})

    -- Compatibilit√© tmux (cf. https://sunaku.github.io/vim-256color-bce.html), qui n√©cessite c√¥t√© tmux :
    -- set-window-option -g xterm-keys on
    -- set -g default-terminal "screen-256color"
    vim.cmd([[set t_ut=]])
    vim.cmd([[redraw]])

    -- configs sp√©cifiques √† certains fichiers :
    local config_for_specific_files = function()
      -- les jenkinsfiles sont √† interpr√©ter en groovy :
      vim.api.nvim_create_autocmd( {"BufEnter"}, { pattern = "*.Jenkinsfile", callback = function () vim.opt_local.filetype = "groovy" end })

      -- les fichiers NOGIT_justfile sont √† interpr√©ter comme des justfiles :
      vim.api.nvim_create_autocmd( {"BufEnter"}, { pattern = "NOGIT_justfile", callback = function () vim.opt_local.filetype = "just" end })

      -- fichier de config typescript sont √† interpr√©ter en javascrip :
      vim.api.nvim_create_autocmd( {"BufEnter"}, { pattern = "tsconfig.json", callback = function () vim.opt_local.filetype = "javascript" end })

      -- √† placer AVANT les autres fold commands (donc avant l'ex√©cution de treesitter) :
      vim.opt.foldmethod = "expr"
      vim.opt.foldexpr = "nvim_treesitter#foldexpr()"
      vim.opt.foldlevel = 99  -- pour corriger le comportement par d√©faut de treesitter, qui commence avec les foldings repli√©s

      -- folding json :
      local json_group = vim.api.nvim_create_augroup('json', { clear = false })
      vim.api.nvim_create_autocmd( {"FileType"}, { pattern = "json", group = 'json', callback = function () vim.opt_local.foldmethod = "syntax" end })

      -- folding avec les brackets triples {{{ }}} pour l'√©dition des fichiers vim (y compris le pr√©sent fichier) :
      local vim_group = vim.api.nvim_create_augroup('vim', { clear = true })
      vim.api.nvim_create_autocmd( {"FileType"}, { pattern = "vim", group = 'vim', callback = function ()
        vim.opt_local.foldlevel = 1  -- je veux les folds quasi-pli√©s quand j'ouvre mon fichier vimrc
      end })
    end -- config_for_specific_files
    config_for_specific_files()

    -- Par d√©faut, on recherche 'tags' jusqu'√† la racine :
    vim.opt.tags="tags;/"

    -- Augmenter la taille de la QuickfixList (et la r√©duire si inutile) :
    -- cf. http://vim.wikia.com/wiki/Automatically_fitting_a_quickfix_window_height
    vim.cmd([[
    function! AdjustWindowHeight(minheight, maxheight)
      exe max([min([line("$"), a:maxheight]), a:minheight]) . "wincmd _"
    endfunction
    autocmd FileType qf call AdjustWindowHeight(3, 40)
    ]])
end -- NEOVIM_SECTION_CODE_SETTINGS
NEOVIM_SECTION_CODE_SETTINGS()



function NEOVIM_SECTION_PLUGINS()
    -- lancement de lazy.nvim :
    local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
    if not vim.loop.fs_stat(lazypath) then
      vim.fn.system({
        "git",
        "clone",
        "--filter=blob:none",
        "https://github.com/folke/lazy.nvim.git",
        "--branch=stable", -- latest stable release
        lazypath,
      })
    end
    vim.opt.rtp:prepend(lazypath)


    local plugins = {
        -- file browser :
        {
            "https://github.com/nvim-tree/nvim-tree.lua",
            version = "*",
            lazy = false,
            dependencies = {
                "nvim-tree/nvim-web-devicons",
                },
            config = function()
                -- nvim-tree recommande de disabler netrw, cf. :help nvim-tree-netrw
                vim.g.loaded_netrw       = 1
                vim.g.loaded_netrwPlugin = 1

                require("nvim-tree").setup {
                    actions = {
                        open_file = {
                            quit_on_open = true,
                        },
                    },
                    sort_by = "case_sensitive",
                    view = {
                        width = 60,
                    },
                    renderer = {
                        group_empty = true,
                    },
                    filters = {
                        dotfiles = true,
                    },

                    -- configs suggested by https://github.com/ahmedkhalf/project.nvim :
                    sync_root_with_cwd = true,
                    respect_buf_cwd = true,
                    update_focused_file = {
                        enable = true,
                        update_root = true
                        },
                }
                -- F8 = ouvrir nvim-tree sur le fichier courant :
                vim.keymap.set({'n', 'i', 'v'}, '<F8>', ':NvimTreeFindFileToggle<CR>', { noremap = true })

                -- S-F8 = ouvrir nvim-tree sur le git-root :
                -- attention, sous neovim, pour qu'un shortcut S-Fxx marche, il faut utiliser F(xx+12) :
                local function get_git_root()
                    local dot_git_path = vim.fn.finddir(".git", ".;")
                    return vim.fn.fnamemodify(dot_git_path, ":h")
                end
                vim.keymap.set({'n', 'i', 'v'}, '<F20>', ':NvimTreeToggle ' .. get_git_root() .. '<CR>', { noremap = true })
            end,
        },

        -- TELESCOPE = fuzzy finder of... things (files, tags, LSP symbols, git commits, etc.)
        {
            'https://github.com/nvim-telescope/telescope.nvim',
            tag = '0.1.4',
            dependencies = { 'nvim-lua/plenary.nvim' },
            config= function()
              require('telescope').setup{
              defaults = {
                dynamic_preview_title = true,
                },
              }

              -- telescope for non-LSP things :
              -- parcourir l'aide vim avec telescope (Ctrl+T pour ouvrir l'aide dans un nouveau tab)
              vim.keymap.set({'n', 'i', 'v'}, '<C-h>', require('telescope.builtin').help_tags, { noremap = true })

              -- visualiser les buffers (:help buffers pour avoir la signification des caract√®res) :
              vim.keymap.set({'n', 'i', 'v'}, '<C-b>', function() require('telescope.builtin').buffers() end, { noremap = true })

              -- Ctrl+p already use in vscode : https://linuxpip.org/vscode-find-file/
              vim.keymap.set({'n', 'i', 'v'}, '<C-p>', function() require('telescope.builtin').find_files({path_display={"truncate"}}) end, { noremap = true })

              -- grepper le r√©pertoire courant avec telescope :
              vim.keymap.set({'n', 'i', 'v'}, '<C-A-g>', require('telescope.builtin').live_grep, bufopts)

              -- Chaque commande telescope est utilisable sous deux formes qui sont √©quivalentes :
              -- :Telescope buffers
              -- :lua require('telescope.builtin').buffers()

              -- Quelques commandes telescope qui peuvent √™tre utiles :
              -- :Telescope buffers
              -- :Telescope highlights
              -- :Telescope man_pages
              -- :Telescope help_tags
              -- :Telescope vim_options
              -- :Telescope autocommands = lister les commandes automatiques
              -- :Telescope keymaps      = lister les raccourcis d√©finis
              -- :Telescope builtin      = lister les builtin telescope

            end,
        },

        -- telescope picker sur les fichiers r√©cents :
        {
            "smartpde/telescope-recent-files",
            config= function()
                require("telescope").load_extension("recent_files")
                -- je choisis le shortcut "gp" pour se rapprocher de <Ctrl+p> qui est un autre picker sur les fichiers
                vim.keymap.set({"n"}, "gp", require('telescope').extensions.recent_files.pick, {noremap = true, silent = true})
            end,
        },

        -- enhances ga to display info on a character, including its digraph code
        {
            'https://github.com/tpope/vim-characterize'
        },

        -- align tokens of a line according to a separator :
        {
            "https://github.com/godlygeek/tabular.git",
            cmd = "Tabularize",
            init = function()
                -- Ctrl+T pour tabularize :
                vim.keymap.set({'v',}, '<C-T>', ':Tabularize /', { noremap = true })
            end,
        },

        -- surround :
        {
            "https://github.com/tpope/vim-surround.git",
        },

        -- repeat a surrounding command
        {
            "https://github.com/tpope/vim-repeat",
        },

        -- comment :
        {
            'https://github.com/numToStr/Comment.nvim',
            config = function()
                require('Comment').setup()
            end,
        },

        -- languages parsing :
        -- apr√®s avoir test√© polyglot, je choisis treesitter qui vient avec une killer feature = le folding de code
        {
            "https://github.com/nvim-treesitter/nvim-treesitter",
            build = function()
              require("nvim-treesitter.install").update({ with_sync = true })()
            end,
            config = function ()
              local configs = require("nvim-treesitter.configs")
              configs.setup({
                -- les parsers sont install√©s dans :
                --      ~/.local/share/nvim/lazy/nvim-treesitter/parser
                -- ne pas h√©siter √† supprimer manuellement ceux dont je ne veux plus
                --
                -- EDIT 29 avril 2024 = j'avais l'erreur suivante lorsque j'ouvrais un fichier docker :
                -- Failed to load parser for language 'dockerfile': uv_dlopen: /my/home/.local/share/nvim/lazy/nvim-treesitter/parser/dockerfile.so: undefined symbol: tree_sitter_dockerfile_external_scanner_create
                -- "forcer" la r√©installation du parser a corrig√© le probl√®me :
                --    1. commenter/supprimer "dockerfile" dans la liste 'ensure_installed' ci-dessous
                --    2. ajouter "dockerfile" dans la liste 'ignore_install' ci-dessous
                --    3. d√©placer/supprimer le fichier '/my/home/.local/share/nvim/lazy/nvim-treesitter/parser/dockerfile.so'
                --    4. commenter la config du plugin nvim-treesitter dans ~/.vimrc, puis ouvrir nvim, et faire :Lazy clean
                --    5. faire les √©tapes inverses : d√©commenter la config de nvim-treesitter, remettre "dockerfile" dans 'ensure_installed' + le supprimer de 'ignore_install'
                --    6. lancer nvim + :Lazy install ‚Üí il va compiler automatiquement un nouveau fichier 'dockerfile.so' (ce qui fait dispara√Ætre mon bug)
                ensure_installed = {
                  "bash",
                  "c",
                  "cmake",
                  "cpp",
                  "css",
                  "diff",
                  "dockerfile",
                  "dot",
                  "doxygen",
                  "git_config",
                  "git_rebase",
                  "gitcommit",
                  "gitignore",
                  "go",
                  "groovy",
                  "html",
                  "htmldjango",
                  "http",
                  "javascript",
                  "jq",
                  "jsdoc",
                  "lua",
                  "luadoc",
                  "make",
                  -- "markdown",  -- volontairement comment√©, cf. ci-dessous
                  "markdown_inline",
                  "mermaid",
                  "meson",
                  "ninja",
                  "po",
                  "python",
                  "regex",
                  "rust",
                  "sql",
                  "ssh_config",
                  "toml",
                  "typescript",
                  "vim",
                  "vimdoc",
                  "vue",
                  "yaml",
                  },
                sync_install = true,  -- installer les parsers de fa√ßon synchrone
                auto_install = false,  -- ne pas installer un parser automatiquement √† l'entr√©e dans un buffer
                ignore_install = { "markdown" },  -- markdown volontairement d√©sactiv√© :
                  -- disabling treesitter for markdown (I cannot get treesitter's markdown to work with
                  -- vim-markdown-folding, and I value markdown folding more than markdown highlighting...)
                highlight = { enable = true },
                indent = { enable = false },
              })
              -- NOTE : il y a un bug que je n'explique pas avec nvim-treesitter : il emp√™che le d√©marrage automatique des clients LSP.
              --        Pour contourner, il suffit d'√©diter le fichier `:e`, ce qui trigge le d√©marrage du client LSP.
            end,
        },

        -- visualiser les indentations :
        {
            "https://github.com/nvimdev/indentmini.nvim",
            event = 'BufEnter',
            config = function()
                require("indentmini").setup({
                    char = "‚îÇ",
                    exclude = {
                        "markdown",
                        "votl",
                    }
                })
                -- use comment color
                vim.cmd.highlight("default link IndentLine Comment")
            end,
        },

        -- markdown-folding :
        {
            "https://github.com/masukomi/vim-markdown-folding",
            config = function()
                -- for vim-markdown-plugin : folding a level 1 title should also fold all its children :
                vim.api.nvim_create_autocmd({"FileType"}, {
                    pattern = "markdown",
                    callback = function (opts)
                        -- see https://neovim.io/doc/user/lua-guide.html#_-vim.opt
                        -- vim.opt: behaves like :set
                        vim.opt.foldexpr = "NestedMarkdownFolds()"
                    end,
                })
            end,
        },

        -- make searched line pulse briefly to ease visualization
        {
            "https://github.com/inside/vim-search-pulse",
            config = function()
                -- strict √©quivalent de :  let g:vim_search_pulse_color_list = [22, 28, 34, 40, 46]
                vim.g.vim_search_pulse_color_list = {22, 28, 34, 40, 46}
            end,
        },

        -- smooth scrolling (to ease visualizing Ctrl-down/Ctrl-up)
        {
            "karb94/neoscroll.nvim",
          config = function ()
              require('neoscroll').setup {}
          end
        },

        -- nvim LSP config :
        {
            "https://github.com/neovim/nvim-lspconfig",
        },

        -- running generic tools as LSP servers
        {
            "https://github.com/jose-elias-alvarez/null-ls.nvim",
        },

        -- rust-tools :
        {
            "https://github.com/simrat39/rust-tools.nvim",
        },


        -- highlight same words as the one under cursor
        -- note : pour visualiser dynamiquement les highlights groups :
        --   :so $VIMRUNTIME/syntax/hitest.vim
        {
            'https://github.com/tzachar/local-highlight.nvim',
            config = function()
                -- √™tre plus r√©actif que les 4000 ms par d√©faut :
                vim.api.nvim_set_option('updatetime', 300)

                require('local-highlight').setup({
                    file_types = {'python', 'cpp', 'rust'},
                    hlgroup = 'TabLine',
                    insert_mode = false,
                })
            end
        },

        -- auto cd to git root dir :
        {
            "https://github.com/ahmedkhalf/project.nvim",
            config = function()
                require('project_nvim').setup {
                  detection_methods = { "pattern" },  -- lsp sometimes sets root to ~ (and I don't really want lsp root anyway : I want git)
                }

            end,
        },

        -- justfile syntax
        {
            "https://github.com/NoahTheDuke/vim-just",
        },

        -- outline des structures LSP du buffer courant :
        {
            "https://github.com/hedyhli/outline.nvim",
            lazy = true,
            cmd = { "Outline", "OutlineOpen" },
            keys = {
                { "<F9>", "<cmd>Outline<CR>", desc = "Toggle outline" },
            },
                -- par d√©faut, le folding n'est ouvert que pour la ligne actuelle (les autres sont repli√©s)
                -- ? pour lister les shortcuts
                -- q ou <Esc> pour quitter
                -- <Tab> pour fold/unfold la ligne actuelle
                -- <Shift-Tab> pour fold/unfold tous les items
                -- R pour reset le folding √† la ligne actuelle
                -- <CTRL-j/k> pour naviguer de tag en tag, tout en d√©pla√ßant le buffer (et Ctrl+fl√™ches ne fonctionne pas...)

            config = function()
                require("outline").setup {
                    -- unfold all at startup :
                    symbol_folding = {
                      autofold_depth = false,
                    },
                }
            end,
        },

        -- statusline :
        {
            'https://github.com/nvim-lualine/lualine.nvim',
            dependencies = {
                "nvim-tree/nvim-web-devicons",
                },
            config = function()

                local function get_total_lines()
                  local total_lines = vim.api.nvim_buf_line_count(vim.api.nvim_get_current_buf())
                  return string.format("%s lines", total_lines)
                end
                require('lualine').setup{
                      options = {
                        icons_enabled = true,
                        theme = 'nord',
                        component_separators = { left = '|', right = '|'},
                        section_separators = { left = '', right = ''},
                        always_divide_middle = false,

                        -- ce qui suit permet d'emp√™cher lualine d'√©craser les titres des fen√™tres de nvim-dap-ui :
                        -- cf. https://www.reddit.com/r/neovim/comments/1054k8y/mixing_lualine_and_nvimdapui/
                        -- pour conna√Ætre l'id de fen√™tre, positionner le curseur dessus, puis :echo &ft
                        ignore_focus = {
                          "dapui_watches",
                          "dapui_breakpoints",
                          "dapui_scopes",
                          "dapui_console",
                          "dapui_stacks",
                          "dap-repl"
                        },
                      },
                      sections = {
                        lualine_a = {
                            {
                                'mode',
                                fmt = function(mode)
                                    return string.format("%-8s", mode)  -- le mode doit toujours occuper la m√™me largeur
                                end
                            },
                        },
                        lualine_b = {'branch', 'diff', 'diagnostics'},
                        lualine_c = {
                            {
                                'filename',
                                path = 1,
                                symbols = {
                                            modified = '[‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè MODIFIED ‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè‚óè]',
                                            readonly = '[READONLY¬ß-]',      -- Text to show when the file is non-modifiable or readonly.
                                            unnamed = '[No Name]', -- Text to show for unnamed buffers.
                                            newfile = '[New]',     -- Text to show for newly created file before first write
                                            directory =  'Óóæ',     -- Text to show when the buffer is a directory
                                  },
                            },
                        },
                        lualine_x = {'progress'},
                        lualine_y = {
                            {'encoding'},
                            {
                              'fileformat',
                              symbols = {
                                unix = ' EOL=unix ',
                                dos = ' EOL=windows ',
                                mac = ' EOL=mac ',
                              },
                            },
                            {
                                'filetype',
                                icon = { align = 'right' },
                            },
                        },
                        lualine_z = {'location', get_total_lines}
                      },

                      -- NDM : inactive p.ex. parce qu'on est sur un autre vsplit
                      inactive_sections = {
                        lualine_a = {},
                        lualine_b = {},
                        lualine_c = {'filename'},
                        lualine_x = {},
                        lualine_y = {},
                        lualine_z = {}
                      },
                      tabline = {},
                      winbar = {},
                      inactive_winbar = {},
                      extensions = {'quickfix', 'nvim-tree', 'lazy'},
                }
            end,
        },

        -- Alternate source/header cpp :
        {
            "https://github.com/ton/vim-alternate",
            config = function()
              vim.g.AlternatePaths = {'.', '../public/*/', '../../impl'} -- j'aurais aim√© d√©finir ../public/COMPONENT/ mais √ßa n'est pas possible...
              vim.keymap.set('n', '<A-o>', '<cmd>Alternate<CR>', { noremap=true, silent=true})
              vim.keymap.set('i', '<A-o>', '<ESC><cmd>Alternate<CR>', { noremap=true, silent=true})
              vim.keymap.set('v', '<A-o>', '<ESC><ESC><cmd>Alternate<CR>', { noremap=true, silent=true})
            end,
        },

        -- vim-outliner colors + foldings :
        {
            "https://github.com/vimoutliner/vimoutliner.git",
            ft = 'votl',
            build = function()
                -- j'ajoute une √©tape de build custom √† cause de la conjonction de deux faits :
                --
                -- smart_paste :
                --     vimoutliner a une extension "smart_paste" que j'aimerais d√©sactiver
                --     pour la d√©sactiver, il ne faut pas la charger, i.e. que g:vo_modules_load ne contienne pas 'smart_paste'
                --     ceci doit √™tre d√©fini dans le vimoutlinerrc
                --
                -- vimoutlinerrc :
                --     dans mon workflow, je ne veux pas avoir √† g√©rer un fichier de config sp√©cifique √† un plugin
                --     (heureusement que tous les plugins vim ne font pas √ßa...)
                --     mais si je ne d√©finis pas mon propre vimoutlinerrc, le plugin vimoutliner utilise un fichier par d√©faut
                --     ce fichier par d√©faut contient... l'activation du smart_paste :
                --         let g:vo_modules_load = "checkbox:tags:smart_paste"
                --
                -- mon but = je veux √† la fois ne pas avoir √† installer un fichier de config sp√©cifique + d√©sactiver le smart_paste
                -- pour cela, au build du plugin, je remplace le fichier de config par d√©faut du plugin par un √† moi.
                -- (note : on dirait que √ßa cr√©e une erreur avec un autre plugin ; comme elle n'arrive qu'une fois = au build, je n'investigue pas)
                --
                -- Si quelque chose tourne mal, ne pas h√©siter √† commenter le plugin, puis :Lazy clean , puis d√©commenter le plugin.
                local vimoutlinerrc = vim.fn.stdpath("data") .. "/lazy/vimoutliner/vimoutlinerrc"

                -- d'abord on sauvegarde l'ancien fichier :
                local SAVED_vimoutlinerrc = vim.fn.stdpath("data") .. "/lazy/vimoutliner/SAVED__vimoutlinerrc"
                print("OTL tweaking> renaming ", vimoutlinerrc, " to ", SAVED_vimoutlinerrc)
                vim.loop.fs_rename(vimoutlinerrc, SAVED_vimoutlinerrc)

                -- puis on √©crit le nouveau :
                local file = io.open(vimoutlinerrc, "w")
                if file then
                    file:write([[
let g:vo_modules_load = "checkbox:format"

" I prefer a large outline lindewidth :
set tw=120

" a convenient localleader for me ("√ß" instead of ",") :
let maplocalleader = "√ß√ß"
]])
                    file:close()
                else
                    print("OTL tweaking> erreur √† l'√©criture d'un vimoutlinerrc sp√©cial.")
                end
            end,
        },

        -- colorscheme :
        {
            -- je gal√®re √† trouver un colorscheme potable... je finis sur celui-ci :
            'https://github.com/Mofiqul/vscode.nvim',
            lazy = false,
            priority = 1000,
            config = function()
                require('vscode').setup({
                    style = 'light',
                    group_overrides = {
                        Comment = {  fg = "DarkGray"},
                        ["@comment"] = {  fg ="DarkGray"},
                    },
                })
                vim.cmd [[colorscheme vscode]]
            end,
        },

        -- split + join function arguments :
        {
          'https://github.com/Wansmer/treesj',
          dependencies = { 'nvim-treesitter/nvim-treesitter' },
          config = function()
            require('treesj').setup({})
            vim.keymap.set('n', 'gs', require('treesj').toggle, { noremap = true })
          end,
        },

        -- markdown previewer :
        {
            -- n√©cessite deno ; ce que j'ai fait pour l'installer (√ßa n'installe qu'un unique binaire) :
            --     curl -fsSL https://deno.land/x/install/install.sh | sh
            --     mv ~/.deno/bin/deno ~/.local/bin/
            -- NDM : la fen√™tre de preview se mets √† jour dynamiquement avec les modifications du buffer \o/
            "https://github.com/toppair/peek.nvim",
            event = { "VeryLazy" },
            build = "deno task --quiet build:fast",
            config = function()
                require("peek").setup()
                vim.api.nvim_create_user_command("PeekOpen", require("peek").open, {})
                vim.api.nvim_create_user_command("PeekClose", require("peek").close, {})
            end,
        },

        -- debugger = DAP-client :
        {
            "https://github.com/mfussenegger/nvim-dap",
            dependencies = { 'nvim-telescope/telescope-dap.nvim' },  -- surtout utile pour lister les breakpoints
            keys = {
            	-- lazy-load on dap shortcuts (so that the 'g' shortcuts are available for other plugins) :
                'gtb',
                'glb',
                '<leader><F5>',
                '<leader><F9>',
                '<leader><F8>',
                '<leader>q',
            },
            config = function()
                local dap = require('dap')
                dap.adapters.lldb = {
                    type = 'executable',
                    command = '/usr/bin/lldb-dap-18',
                    name = 'lldb'
                }

                -- configuration globale (sera √©cras√©e si besoin par celle de NOGIT_launch.json)
                dap.configurations.cpp = {
                    {
                        name = 'Start C++ debug session',
                        type = 'lldb',
                        request = 'launch',
                        program = function()
                            -- on passera ici s'il n'y a pas de fichier launch.json qui d√©finit le programme √† d√©bugger :
                            return vim.fn.input('Path to executable: ', vim.fn.getcwd() .. '/', 'file')
                        end,
                        cwd = '${workspaceFolder}',
                        stopOnEntry = false,
                        args = {},
                    },
                }

                -- configuration per-project :
                -- √Ä la base, la configuration (notamment, le choix du programme √† d√©bugger) est d√©finie en dur dans le vimrc.
                -- MAIS comme c'est pas vraiment ce qu'on veut (notamment, le choix du programme √† d√©bugger est plut√¥t √† faire
                -- projet par projet), nvim-dap permet d'overwritter la config globale avec une config lue depuis le fichier
                -- launch.json de vscode.
                --
                -- Dans mon setup, je le renomme en NOGIT_launch.json √† la racine du projet. Exemple de contenu :
                --  {
                --    "version": "0.2.0",
                --    "configurations": [
                --      {
                --        "type": "lldb",
                --        "request": "launch",
                --        "name": "Start C++ debug session",
                --        "program": "/home/myself/myproject/builddir/mycomponent/test-of-my-app"
                --      }
                --    ]
                --  }
                --
                -- NOTE : les champs 'type' et 'name' doivent matcher exactement avec ceux de la config globale pour les overwritter.
                require('dap.ext.vscode').load_launchjs('NOGIT_launch.json', { lldb = {'c', 'cpp'} })

                -- pour rendre les breakpoints plus visibles :
                vim.fn.sign_define('DapBreakpoint', {text='üõë', texthl='', linehl='', numhl=''})

                -- utiliser telescope pour l'UI dap :
                require('telescope').load_extension('dap')
            end,
        },

        -- UI pour le debugger :
        {
            "https://github.com/rcarriga/nvim-dap-ui",
            dependencies = {
                "mfussenegger/nvim-dap",
                "nvim-neotest/nvim-nio",
            },
            keys = {
            	-- lazy-load on dap shortcuts (so that the 'g' shortcuts are available for other plugins) :
                'gtb',
                'glb',
                '<leader><F5>',
                '<leader><F9>',
                '<leader><F8>',
                '<leader>q',
            },
            config = function()
                require("dapui").setup()
                -- d√©marrer / arr√™ter une session de debugging :
                vim.keymap.set({'n', 'i', 'v'}, '<leader><F5>', function() require('dapui').open() require('dap').continue() end, { noremap = true })
                vim.keymap.set({'n', 'i', 'v'}, '<leader>q', function() require('dap').terminate() require('dapui').close() end, { noremap = true })

                -- gtb pour [T]oggle un [B]reakpoint  /  glb pour [L]ister les [B]reakpoints :
                vim.keymap.set({'n', 'i', 'v'}, 'gtb', require('dap').toggle_breakpoint, { noremap = true })
                vim.keymap.set({'n', 'i', 'v'}, 'glb', '<ESC>:Telescope dap list_breakpoints<CR>', bufopts)

                -- plusieurs possibilit√©s pour piloter l'avanc√©e du programme en cours d'ex√©cution,  :
                --     mapper un raccourci √† une commande de pilotage :
                --         vim.keymap.set('n', 'gs', require('dap').step_into, { noremap = true })
                --     utiliser l'API dap (cf. :help dat.txt) :
                --         :lua require'dap'.step_into()
                --     utiliser la commande raccourcie d√©finie par dap :
                --         :DapStepInto
                --     cliquer sur les boutons d√©finis par nvim-dap-ui dans la REPL
                --     ^ c'est cette option que je retiens pour commencer.

                -- HOTWO debug en r√©sum√© :
                --    1. √©diter NOGIT_launch.json pour d√©finir le programme √† d√©bugger
                --    2. setter des breakpoints avec gtb (les lister avec glb)
                --    3. d√©marrer la session de debug avec <leader><F5>
                --    4. naviguer dans le programme avec les boutons de la REPL UI
                --    5. utiliser les fen√™tres de nvim-dap-ui pour inspecter l'√©tat
                --    6. arr√™ter la session de debug avec <leader>q

                -- HOWTO use nvim-dap-ui en r√©sum√© :
                --    DAP Scopes = fen√™tre des variables :
                --        <CR> pour expand les variables et inspecter leur contenu
                --    DAP Breakpoints = fen√™tre des breakpoints
                --        o pour jumper sur le breakpoint
                --        t pour toggle le breakpoint
                --    DAP REPL :
                --        utiliser les boutons pour contr√¥ler l'ex√©cution du programme d√©bugg√©
            end,
        },
    }

    require("lazy").setup(plugins, opts)
end -- NEOVIM_SECTION_PLUGINS
NEOVIM_SECTION_PLUGINS()


function NEOVIM_SECTION_VIMOUTLINER_AND_VIMDIFF()
    -- more visible left-column signs :
    vim.cmd.highlight({"FoldColumn", "ctermbg=250"})

    -- options sp√©cifiques √† VimOutliner :
    vim.api.nvim_create_autocmd({"BufEnter"}, {
        pattern = {"*.otl"},
        callback = function (opts)

            -- see https://neovim.io/doc/user/lua-guide.html#_-vim.opt
            -- vim.opt_local: behaves like :setlocal
            vim.opt_local.wrap = true
            vim.opt_local.linebreak = true
            vim.opt_local.termguicolors = false  -- if set at true by colorschemes, this messes up with my vimoutliner colors
            vim.opt_local.foldcolumn = "0"  -- d√©sactiver la colonne √† gauche qui pr√©fixe chaque ligne par son niveau d'indentation

            vim.cmd([[
                " on part d'une base colorscheme :
                colorscheme morning

                " overriding default colors (cf. :help cterm-colors) :
                hi OL1 ctermfg=Black
                hi OL2 ctermfg=DarkRed
                hi OL3 ctermfg=DarkBlue
                hi OL4 ctermfg=DarkYellow
                hi OL5 ctermfg=DarkMagenta
                hi OL6 ctermfg=DarkCyan
                hi OL7 ctermfg=DarkGreen
                hi OL8 ctermfg=Grey

                hi Folded ctermfg=DarkGray ctermbg=Gray


                " I prefer a large outline lindewidth :
                set tw=120

                " a convenient localleader for me ("√ß" instead of ",") :
                let maplocalleader = "√ß√ß"

                " color for body text
                hi BT1 guifg=black	ctermfg=black
                hi BT2 guifg=black	ctermfg=black
                hi BT3 guifg=black	ctermfg=black
                hi BT4 guifg=black	ctermfg=black
                hi BT5 guifg=black	ctermfg=black
                hi BT6 guifg=black	ctermfg=black
                hi BT7 guifg=black	ctermfg=black
                hi BT8 guifg=black	ctermfg=black
                hi BT9 guifg=black	ctermfg=black

                " color for pre-formatted text
                hi PT1 guifg=black	ctermfg=black
                hi PT2 guifg=black	ctermfg=black
                hi PT3 guifg=black	ctermfg=black
                hi PT4 guifg=black	ctermfg=black
                hi PT5 guifg=black	ctermfg=black
                hi PT6 guifg=black	ctermfg=black
                hi PT7 guifg=black	ctermfg=black
                hi PT8 guifg=black	ctermfg=black
                hi PT9 guifg=black	ctermfg=black

                " color for user text (wrapping)
                hi UT1 guifg=black	ctermfg=black
                hi UT2 guifg=black	ctermfg=black
                hi UT3 guifg=black	ctermfg=black
                hi UT4 guifg=black	ctermfg=black
                hi UT5 guifg=black	ctermfg=black
                hi UT6 guifg=black	ctermfg=black
                hi UT7 guifg=black	ctermfg=black
                hi UT8 guifg=black	ctermfg=black
                hi UT9 guifg=black	ctermfg=black

                " color for user text (non-wrapping)
                hi UB1 guifg=black	ctermfg=black
                hi UB2 guifg=black	ctermfg=black
                hi UB3 guifg=black	ctermfg=black
                hi UB4 guifg=black	ctermfg=black
                hi UB5 guifg=black	ctermfg=black
                hi UB6 guifg=black	ctermfg=black
                hi UB7 guifg=black	ctermfg=black
                hi UB8 guifg=black	ctermfg=black
                hi UB9 guifg=black	ctermfg=black
            ]])
            -- vim.cmd.highlight({"Search", "cterm=reverse"})
            -- vim.cmd.highlight({"IncSearch", "cterm=reverse"})
            vim.cmd.highlight({"CurSearch", "ctermbg=LightGray"})

            -- les leading tabulations (importantes en OTL) sont colori√©es en Whitespace, qui est un lien vers NonText
            -- je les veux sans coloration particuli√®res (elles partagent ce groupe avec les trailing whitespace, qui perdront aussi leur background)
            vim.opt_local.list = true
            vim.cmd([[set listchars=trail:‚óè,nbsp:‚ê£,precedes:‚Üê,extends:‚Üí]])
            vim.opt_local.listchars:append({ tab = "  " })
            vim.cmd.highlight({"NonText", "NONE"})
        end,
    })
end -- NEOVIM_SECTION_VIMOUTLINER_AND_VIMDIFF
NEOVIM_SECTION_VIMOUTLINER_AND_VIMDIFF()


function NEOVIM_SECTION_LSP_RELATED()
    -- See `:help vim.diagnostic.*` for documentation on any of the below functions


    -- Use an on_attach function to only map the following keys
    -- after the language server attaches to the current buffer
    local on_lsp_attach = function(client, bufnr)
      -- weirdly, lsp highlights overwrite polyglot (and are awful + laggy), better to disable them :
      -- see https://neovim.io/doc/user/lsp.html#lsp-semantic-highlight
      -- see https://gist.github.com/swarn/fb37d9eefe1bc616c2a7e476c0bc0316
      for _, group in ipairs(vim.fn.getcompletion("@lsp", "highlight")) do
        vim.api.nvim_set_hl(0, group, {})
      end

      -- Enable completion triggered by <c-x><c-o> :
      vim.api.nvim_buf_set_option(bufnr, 'omnifunc', 'v:lua.vim.lsp.omnifunc')
      -- fermer la preview window une fois qu'on a choisi l'autompl√©tion :
      vim.api.nvim_create_autocmd({"CompleteDone"}, { callback = function() vim.cmd.pclose() end})

      -- Mappings.
      -- See `:help vim.lsp.*` for documentation on any of the below functions
      local bufopts = { noremap=true, silent=true, buffer=bufnr }

      -- naviguer entre les erreurs LSP :
      vim.keymap.set('n', '<A-k>', vim.diagnostic.goto_prev, { noremap=true, silent=true})
      vim.keymap.set('n', '<A-j>', vim.diagnostic.goto_next, { noremap=true, silent=true})

      -- native LSP-client :
      vim.keymap.set({'n', 'i', 'v'}, '<F12>', vim.lsp.buf.definition, bufopts)  -- F12 = go to definition in the same tab
      vim.keymap.set({'n', 'i', 'v'}, 'g<F12>', '<ESC><cmd>tab split<CR><cmd>lua vim.lsp.buf.definition()<CR>', bufopts)  -- g-F12 = go to definition in a new tab
      vim.keymap.set({'n', 'v'}, 'gh', vim.lsp.buf.hover, bufopts)
      vim.keymap.set({'n', 'v'}, 'gb', vim.lsp.buf.code_action, bufopts)  -- "gb" car le C (pour [C]ode-actions) et le A (pour code-[A]ctions) sont d√©j√† pris...
      vim.keymap.set('n', '==', vim.lsp.buf.format, bufopts)
      vim.keymap.set('v', '=', vim.lsp.buf.format, bufopts)  -- range format

      -- telescope + LSP = <3
      vim.keymap.set({'n', 'i', 'v'}, '<C-A-t>', require('telescope.builtin').lsp_dynamic_workspace_symbols, bufopts)
      -- to make S-Fxx work in neovim, I have to use Fyy where yy = xx + 12 :
      vim.keymap.set({'n', 'i', 'v'}, '<F24>', function() require('telescope.builtin').lsp_references({path_display={"tail"}}) end, bufopts)  -- S-F12 = who uses this symbol ?


      -- NdM : rename = besoin suffisamment rare pour ne pas ajouter de mapping :
      -- un alias me permet de compl√©ter la commande plus facilement (il va demander le nouveau nom) :
      --
      --      :lua lsp_rename()
      --
      -- attention : des buffers peuvent √™tre modifi√©s par le renommage sans √™tre directement visibles !
      -- contournement 1 = les consulter (:Telescope buffers)
      -- contournement 2 = tout enregistrer avec :wa (= :writeall)
      lsp_rename = vim.lsp.buf.rename

      -- NdM : moins utile que 'definition' :
      -- vim.keymap.set({'n', 'i', 'v'}, '<F12>', vim.lsp.buf.declaration, bufopts)

      -- NdM : non-pris en charge par clangd et/ou pyright :
      -- vim.keymap.set({'n', 'i', 'v'}, '<F12>', vim.lsp.buf.type_definition, bufopts)
      -- vim.keymap.set({'n', 'i', 'v'}, '<F12>', vim.lsp.buf.implementation, bufopts)

      -- toggling diagnostics (there is no native function for that) :
      -- inspired by https://www.reddit.com/r/neovim/comments/ng0dj0/lsp_diagnostics_query_is_there_an_way_to_toggle/
      vim.g.diagnostics_active = true
      function _G.toggle_diagnostics()
        if vim.g.diagnostics_active then
          print('disabling diagnostics...')
          vim.g.diagnostics_active = false
          vim.diagnostic.disable()
        else
          print('enabling diagnostics...')
          vim.g.diagnostics_active = true
          vim.diagnostic.enable()
        end
      end
      -- gt sert normalement √† switcher de tab, mais je n'utilise pas -> g[T]oggle :
      vim.keymap.set({'n', 'v'}, 'gt', _G.toggle_diagnostics, bufopts)

      -- Je pr√©f√®re ces couleurs pour les diagnostics LSP :
      -- :hi pour voir les highlights actuels (avec exemples)
      -- pour info, valeurs par d√©faut :
      -- DiagnosticError xxx ctermfg=1 guifg=Red
      -- DiagnosticWarn xxx ctermfg=3 guifg=Orange
      -- DiagnosticInfo xxx ctermfg=4 guifg=LightBlue
      -- DiagnosticHint xxx ctermfg=7 guifg=LightGrey
      -- NDM : vim.cmd() permet de passer des commandes vimscript
      vim.cmd("hi DiagnosticError cterm=underline,bold ctermfg=1 gui=bold guifg=Red")
      vim.cmd("hi DiagnosticWarn  cterm=underline,bold ctermfg=3 gui=bold guifg=Orange")
      vim.cmd("hi DiagnosticInfo  cterm=underline,bold ctermfg=4 gui=bold guifg=LightBlue")
      vim.cmd("hi DiagnosticHint  cterm=underline,bold ctermfg=0 gui=bold guifg=Black")
    end  -- on_lsp_attach

    require('lspconfig')['pyright'].setup{
        on_attach = on_lsp_attach,
        flags = lsp_flags,
    }
    require('lspconfig')['clangd'].setup{
        on_attach = on_lsp_attach,
        flags = lsp_flags,
        cmd = { "clangd-18" },
    }
    -- 3 d√©cembre 2024 = tsserver est deprecated ; je fixerai quand je referai du js
    -- require('lspconfig')['tsserver'].setup{
    --     on_attach = on_lsp_attach,
    --     flags = lsp_flags,
    -- }
    require('rust-tools').setup{
        server = {on_attach = on_lsp_attach},
        flags = lsp_flags,
        tools = {inlay_hints = {
            max_len_align = true,
            highlight= "RustToolsTypeInfo",
            }
        },
    }
    -- null-lsp :
    local null_ls = require("null-ls")
    local sources = {
        null_ls.builtins.diagnostics.flake8.with({extra_args = {"--max-line-length","120"}}),
    }
    null_ls.setup({ sources = sources })
end -- NEOVIM_SECTION_LSP_RELATED
NEOVIM_SECTION_LSP_RELATED()


function NEOVIM_SECTION_MY_CHEATSHEET()
    -- FIXME : ceci pourrait plut√¥t √™tre un fichier OTL, et la fonction se contenterait de le charger dans un tab
    --         (un OTL sera plus facile √† √©crire, maintenir et m√™me consulter)
    function display_mycheatsheet_in_tab()
        local mycheatsheet_str = [=[
    Pour afficher cette cheatsheet :   :Cheat  /  :call CheatsheetFunction()
    ¬†
    Pour grepper l'help avec telescope : CTRL+h  /  :Telescope help_tags
    ¬†
    ======= SEARCH :
        :copen / :ccl[ose]     ouvrir / fermer la quickfix list
        F8                     ouvrir nvim-tree sur le r√©pertoire courant
        S-F8                   ouvrir nvim-tree sur le git-root
          ‚îú‚îÄ g?                 afficher les commandes
          ‚îú‚îÄ q                  fermer nvim-tree
          ‚îú‚îÄ Entr√©e             ouvrir le fichier s√©lectionn√© dans le buffer courant
          ‚îú‚îÄ C-t / C-x / C-h    ouvrir le fichier s√©lectionn√© dans un nouveau tab / vsplit / hsplit
          ‚îú‚îÄ o                  ouvrir/fermer un r√©pertoire
          ‚îú‚îÄ H                  toggle l'affichage des fichiers cach√©s
          ‚îú‚îÄ a / r / d          ajouter / renommer / supprimer un fichier
          ‚îú‚îÄ y  /  gy           copier le nom / le chemin complet du fichier
          ‚îî‚îÄ -  /  P            remonter d'un cran dans la hi√©rarchie / se d√©placer sur le r√©pertoire parent
    ¬†
    ======= LAZY.NVIM :
        https://github.com/folke/lazy.nvim
          ‚îî‚îÄ :Lazy              afficher l'UI de gestion de lazy.nvim (qui donne acc√®s √† toutes les commandes)
    ¬†
    ======= DEV :
        CTRL-o / CTRL-i        jumper √† un emplacement pr√©c√©dent / suivant du curseur
        LSP
          ‚îú‚îÄ F12   (g+F12)       go to definition (in a new  tab)
          ‚îú‚îÄ Shift+F12           see references
          ‚îú‚îÄ gh                  infos sur le symbole courant dans une bulle hover
          ‚îú‚îÄ Alt+j / Alt+k       go to next/previous error
          ‚îú‚îÄ :LspStop/Start      (d√©s)activer le LSP client (semble mal marcher avec null-ls...)
          ‚îú‚îÄ :LspInfo            des infos sur la config des LSP (e.g. quels linters sont actifs)
          ‚îú‚îÄ :LspLog             fichier de log LSP
          ‚îú‚îÄ gt                  toggle les diagnostics LSP
          ‚îî‚îÄ CTRL+x CTRL+o       compl√©tion intelligente respectant le contexte via LSP
        CTRL+n                 compl√©tion 'dumb'
        Telescope
          ‚îú‚îÄ CTRL-n / CTRL-p     naviguer dans les matchs en mode insertion
          ‚îú‚îÄ Entr√©e / CTRL-t     ouvrir le match dans l'onglet courant / un nouvel onglet
          ‚îú‚îÄ CTRL+/  ou  ?       aide sur les shortcuts de telescope (insert-mode ou normal-mode)
          ‚îú‚îÄ CTRL+ALT+g          live_grep dans le r√©pertoire courant
          ‚îú‚îÄ CTRL+ALT+t          rechercher des noms de symboles dans l'index LSP
          ‚îî‚îÄ CTRL+p              fuzzy search files by name (telescope)
        Alt-o                  alterner entre .h / .cpp
        CTRL-t + <sep>         (visual) tabularize avec des colonnes s√©par√©es par <sep>
        gs                     split/join les arguments d'une fonction
        ==   (visual : =)      reformatter tout le fichier (ou uniquement la s√©lection visuelle)
    ¬†
    ======= MES ALIAS PERSOS (hors plugins) :
        CTRL-HAUT/BAS          scroller une ligne vers le bas/haut
        ALT-DROITE/GAUCHE      :tabNext / :tabPrev  (√©galement commandes natives : gt/gT)
        √ß√ßh                    toggle hlsearch
        √ß√ßi                    toggle ignorecase
        √ß√ßn                    toggle line numbers
        √ß√ßsyntax               refresh la syntaxe
    ¬†
    ======= OTHER CORE VIM FEATURES :
        :help fold
          ‚îú‚îÄ:set foldlevel=3    setter le foldlevel
          ‚îú‚îÄzO / zC             ouvrir/fermer le fold actuel et tous ses fils
          ‚îú‚îÄzr / zm             ouvrir/fermer un niveau de fold suppl√©mentaire
          ‚îî‚îÄzR / zM             ouvrir/fermer TOUS les folds du fichier (utile dans vimdiff)
        nvim -d -O file1 file2
          ‚îú‚îÄdp                  [P]ut the diff to other file
          ‚îú‚îÄdo                  [O]btain the diff from other file
          ‚îú‚îÄ:diffupdate         refresh diff
          ‚îú‚îÄCTRL-w + w          mettre le curseur sur l'autre fichier
          ‚îî‚îÄzR / zM             afficher/masquer les portions identiques du fichier
        :help split
          ‚îú‚îÄCTRL-w + _          maximiser le split courant
          ‚îú‚îÄCTRL-w + =          √©galiser les splits
          ‚îú‚îÄ:res[ize] 15        setter la taille du split √† 15
          ‚îú‚îÄ:res[ize] +3        augmenter la taille du split de 3 (√©galement CTRL-w - 3+)
          ‚îú‚îÄCTRL-w + w          d√©placer le focus sur un autre split
          ‚îî‚îÄCTRL-w + CTRL-r     swapper les splits
        :help C-r
          ‚îú‚îÄCTRL-r + REG        ins√®re le contenu du registre REG (\" pour le registre anonyme)
          ‚îú‚îÄCTRL-r + /          ins√®re le pattern de recherche
          ‚îî‚îÄCTRL-r + CTRL-w     ins√®re le mot sous le curseur
        :norm! @a              applique la macro 'a' (√† utiliser sur un groupe de lignes)
        :set conceallevel=0    ne pas masquer de texte (e.g. markdown)
        :echo mapleader        afficher le <leader> actuel
        :map STRING            afficher les mappings commen√ßant par STRING -> doc de mes raccourcis !
        :map <leader>          afficher les mappings commen√ßant par <leader> (marche aussi avec p.ex. <F5>)
        ma / 'a                d√©finir la / sauter vers la marque <a>
        ''                     apr√®s avoir saut√© vers une marque, '' permet de revenir l√† o√π on √©tait
    ¬†
        ... to be continued ...
    ]=]
        vim.cmd("tabnew MYCHEATSHEET")

        -- convert single string into table of lines :
        local lines = {}
        for s in mycheatsheet_str:gmatch("[^\r\n]+") do
            table.insert(lines, s)
        end

        vim.fn.append(0, lines)
        vim.fn.cursor(1, 1)
    end

    -- how to display my sheatsheet :
    vim.api.nvim_create_user_command('Cheat', display_mycheatsheet_in_tab, {})
    vim.api.nvim_create_user_command('Cheatsheet', display_mycheatsheet_in_tab, {})
end -- NEOVIM_SECTION_MY_CHEATSHEET
NEOVIM_SECTION_MY_CHEATSHEET()


EOF
endif  " has("nvim")
