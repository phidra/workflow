"########################################################################################################################
"# zR / zM  = déplier / replier tous les folds
"########################################################################################################################

" READING GUIDELINE : la config est splittée en deux sections :
"   - une section en vimscript pour les situations basiques
"   - une section en lua, utile pour les situations poweruser (e.g. coding)
"
" L'idée est que la config lua a vocation à n'être utilisée qu'avec neovim sur mes postes de travail,
" alors que la config vimscript peut être utilisée avec un vim vanilla, depuis n'importe où.


"# GÉNÉRALITÉS : {{{
"########################################################################################################################

set tabstop=4         " largeur d'affichage des tabulations
set shiftwidth=4      " nombre d'espaces à insérer quand on indente
set expandtab         " forcer l'utilisation des espaces au lieu de tabulations
set textwidth=0       " désactiver la coupure automatique d'une ligne
set mouse=a           " activer la souris (par contre on ne peut-plus copier-coller une sélection à la souris depuis une autre application)
set incsearch         " surbrillance en cours de tapage d'une recherche
set hlsearch          " surbrillance des résultats d'une recherche
set noignorecase      " ignorer la casse dans les recherches :
set tabpagemax=30     " pas plus de tant d'onglets
set bufhidden=delete  " suppression d'un buffer lorsqu'il devient caché :
set breakat=" "       " seuls les espaces 'cassent' des lignes (e.g. pour ne pas splitter une URL)
set foldlevelstart=99 " Tous les folds automatiques sont ouverts par défaut :
set whichwrap=b,s,<,>,[,],h,l  " pouvoir se déplacer d'une ligne à l'autre avec ces touches
set wrap
set backspace=indent,eol,start  " cf. https://vi.stackexchange.com/questions/2162/why-doesnt-the-backspace-key-work-in-insert-mode
set splitbelow
set splitright
set title
set list
set showbreak=↪
set listchars=tab:▶\ ,trail:●,nbsp:␣,precedes:←,extends:→
set redrawtime=10000  " autorise le chargement de syntaxe à prendre plus de temps que les 2s par défaut
set wildignore+=*/tmp/*,*.so,*.o,*.swp,*.zip,*.pyc
set nocompatible
set switchbuf+=usetab,newtab


" Par défaut, on désactive les pair-match facilities, (à réactiver pour les buffers de code).
" (en effet, hors du code, c'est relou de voir se colorer une parenthèse quand je survole sa parente)
let g:loaded_matchparen = 0
set noshowmatch

let g:mapleader = "ç"

" Coloration syntaxique (désactivé pour le mode vimdiff, pour bien voir tous les caractères)
if ! &diff
    syntax on                  " À placer AVANT la ligne filetype
    filetype plugin indent on  " À placer APRÈS la ligne syntax
endif

colorscheme morning
" set Search highlight-group to IncSearch (which I prefer) :
hi! link Search IncSearch

" Better foldline :
" Copied from http://gregsexton.org/2011/03/27/improving-the-text-displayed-in-a-vim-fold.html
" The goal is to see a bigger part of a folded line (particularly useful on OTL files)
function CustomFoldText()
    "get first non-blank line
    let fs = v:foldstart
    while getline(fs) =~ '^\s*$' | let fs = nextnonblank(fs + 1)
    endwhile
    if fs > v:foldend
        let line = getline(v:foldstart)
    else
        let line = substitute(getline(fs), '\t', repeat(' ', &tabstop), 'g')
    endif

    let w = winwidth(0) - &foldcolumn - (&number ? 8 : 0)
    let foldSize = 1 + v:foldend - v:foldstart
    let foldSizeStr = " " . foldSize . " lines "
    let foldLevelStr = repeat("+--", v:foldlevel)
    let lineCount = line("$")
    let foldPercentage = printf("[%.1f", (foldSize*1.0)/lineCount*100) . "%] "
    let expansionString = repeat(".", w - strwidth(foldSizeStr.line.foldLevelStr.foldPercentage))
    return line . expansionString . foldSizeStr . foldPercentage . foldLevelStr
endf

" for whatever reasons, foldtext must be manually set for each buffer instead of globally...
autocmd BufEnter *.otl setlocal foldtext=CustomFoldText()
autocmd BufEnter *.md setlocal foldtext=CustomFoldText()

" (généralités) }}}


"# TABS AND STATUSLINE {{{
"########################################################################################################################

" Barre de statut (cf. :help statusline) :
set laststatus=2
if has("statusline")
  set statusline=%m       " flag de modification : [+]
  set statusline=\ %F     " chemin du fichier édité
  set statusline+=%r%h%w  " flags RO / help / preview
  set statusline+=%=      " passe de l'autre côté de la ligne
  set statusline+=FT=%y   " filetype
  set statusline+=\ \|\ EOL=%{&fileformat}           " fileformat (ex: python, ou vo_base)
  set statusline+=\ \|\ %{(&fenc==\"\"?&enc:&fenc)}  " encoding
  set statusline+=\ \|\ C=%v                         " colonne actuelle
  set statusline+=\ \|\ L=%l/%L                      " ligne actuelle / lignes totales
endif

" Changement de couleur en mode insertion (help ctermbg) :
if version >= 700
  autocmd InsertEnter * hi StatusLine term=reverse ctermfg=1
  autocmd InsertLeave * hi StatusLine term=reverse ctermfg=0 ctermbg=7
endif

" Ligne des tabs (cf. :help setting-tabline)
highlight UnsavedTabLine term=underline cterm=underline ctermfg=1 ctermbg=7 gui=underline guibg=LightGrey
highlight UnsavedTabLineSel ctermfg=1 term=bold cterm=bold gui=bold " Copie modifiée de TabLineSel

function MyTabLine()
    let return_string = ''
    for fake_tab_number in range(tabpagenr('$'))
        " Initialisation des variables :
        let tab_number = fake_tab_number + 1
        let buflist = tabpagebuflist(tab_number)
        let win_number = tabpagewinnr(tab_number)
        let buffer_number = buflist[win_number - 1]
        let is_buffer_modified = getbufvar(buffer_number, "&modified")

        " Coloration du tab courant (dépend du fait qu'il soit sélectionné, et qu'il soit modifié) :
        if tab_number == tabpagenr()
            if is_buffer_modified
                let return_string .= '%#UnsavedTabLineSel#'
            else
                let return_string .= '%#TabLineSel#'
            endif
        else
            if is_buffer_modified
                let return_string .= '%#UnsavedTabLine#'
            else
                let return_string .= '%#TabLine#'
            endif
        endif

        " Numéro de l'onglet (pour les clics de souris) :
        let return_string .= '%' . tab_number . 'T'

        " Le titre du tab courant est le nom court du buffer :
        let tab_name = fnamemodify(bufname(buffer_number), ":t")
        if empty(tab_name)
            let tab_name = "*EMPTY*"
        endif
        let return_string .= ' ' . tab_name . ' '
    endfor

    " Complétion de la ligne avec TabLineFill, et reset du tab page number :
    let return_string .= '%#TabLineFill#%T'

    " Ajout du symbole de fermeture, aligné à droite :
    let close_symbol = 'X'
    if tabpagenr('$') > 1
        let return_string .= '%=%#TabLine#%999X' . close_symbol
    endif

    return return_string
endfunction

set tabline=%!MyTabLine()

" (tabs and statusline) }}}


"# MES ALIAS HORS PLUGINS  {{{
"########################################################################################################################

" ATTENTION : les commandes Alt sont interceptées par tmux (et doivent être
" forwardées avec send-keys dans la config tmux).

" Navigation dans les onglets avec ALT + gauche/droite (EDIT : fonctionne aussi avec gt/gT)
noremap  <A-Right>        :tabn<CR>
inoremap <A-Right>   <Esc>:tabn<CR>
noremap  <A-Left>         :tabp<CR>
inoremap <A-Left>    <Esc>:tabp<CR>

" Défiler l'écran (sans bouger le curseur) avec CTRL + haut/bas
noremap   <C-Down> <C-E>
inoremap  <C-Down> <C-E>
noremap!  <C-Down> <C-X><C-E>
" NOTE : pour C-Y, je dois désactiver le timeout pour ne pas interférer avec emmet.
noremap   <C-Up>   :set notimeout nottimeout<CR><C-Y>:set timeout ttimeout<CR>
inoremap  <C-Up>   <Esc>:set notimeout nottimeout<CR><C-Y>:set timeout ttimeout<CR>i
noremap!  <C-Up>   <C-X><C-Y>

" Toggle d'options utiles :
noremap <leader><leader>h :set hlsearch!<CR>:set hlsearch?<CR>
noremap <leader><leader>i :set ignorecase!<CR>:set ignorecase?<CR>
noremap <leader><leader>n :set nu!<CR>:set nu?<CR>
noremap! <leader><leader>h <Esc>:set hlsearch!<CR>:set hlsearch?<CR>a
noremap! <leader><leader>i <Esc>:set ignorecase!<CR>:set ignorecase?<CR>a
noremap! <leader><leader>n <Esc>:set nu!<CR>:set nu?<CR>a

" Refresh de la syntaxe :
noremap <leader><leader>syntax :syntax sync fromstart<CR>
noremap! <leader><leader>syntax <Esc>:syntax sync fromstart<CR>a

 " (MES ALIAS HORS PLUGINS) }}}

"========================================================================================================================
" ^ ci-dessus, la config en vimscript
"
" v ci-dessous, la config en lua
"========================================================================================================================


if has("nvim")
lua << EOF
--  cf. https://neovim.io/doc/user/lua-guide.html


--# VIMOUTLINER+VIMDIFF {{{
--########################################################################################################################

-- more visible left-column signs :
vim.cmd.highlight({"FoldColumn", "ctermbg=250"})

-- options spécifiques à VimOutliner :
vim.api.nvim_create_autocmd({"BufEnter"}, {
    pattern = {"*.otl"},
    callback = function (opts)
        -- see https://neovim.io/doc/user/lua-guide.html#_-vim.opt
        -- vim.opt_local: behaves like :setlocal
        vim.opt_local.wrap = true
        vim.opt_local.linebreak = true
        vim.opt_local.listchars:append({ tab = "  " })
    end,
})

-- (VIMOUTLINER+VIMDIFF) }}}


--# CODE SETTINGS {{{
--########################################################################################################################

-- settings spécifiques aux buffers contenant du code :
vim.api.nvim_create_autocmd({"BufEnter"}, {
    pattern = {
        '*.html',
        '*.css',
        '*.py',
        '*.js',
        '*.json',
        '*.ts',
        '*.c',
        '*.cpp',
        '*.h',
        '*.hpp',
        '*.rb',
        '*.sh',
        '*.Jenkinsfile',
        '*.rs'
    },
    callback = function ()
        -- limites verticales à 120 caractères :
        vim.opt.colorcolumn = {100, 120}
        vim.cmd.highlight({"ColorColumn", "ctermbg=LightRed", "ctermfg=Black"})

        -- position du curseur :
        vim.opt.cursorline = true
        vim.opt.cursorcolumn = true
        vim.cmd.highlight({"CursorColumn", "ctermbg=250"})
        vim.cmd.highlight({"CursorLine", "ctermbg=250"})
        -- cf. https://smarttech101.com/how-to-configure-colorscheme-in-vim-neovim
        -- cf. https://gist.github.com/vivkin/567896630dbc588ad470b8196c601ad1#file-256-color-table-sh

        -- trailing whitespaces + nbsp + tabulations :
        vim.cmd.highlight({"TrailingWhitespace", "ctermbg=red"})
        vim.cmd.match({"TrailingWhitespace", [[/\s\+$/]]})
        vim.cmd.highlight({"nbspColor", "ctermbg=red"})
        vim.fn.matchadd("nbspColor", " ")
        vim.cmd.highlight({"TabulationsColor", "ctermbg=red"})
        vim.fn.matchadd("TabulationsColor", "	")

        -- numéros de lignes :
        vim.opt.nu = true;
    end,
})

-- coloration des type-infos par rust-tools à la fin de la ligne :
vim.cmd.highlight({"RustToolsTypeInfo", "cterm=bold"})

-- Compatibilité tmux (cf. https://sunaku.github.io/vim-256color-bce.html), qui nécessite côté tmux :
-- set-window-option -g xterm-keys on
-- set -g default-terminal "screen-256color"
vim.cmd([[set t_ut=]])
vim.cmd([[redraw]])

-- configs spécifiques à certains fichiers :
local config_for_specific_files = function()
  -- les jenkinsfiles sont à interpréter en groovy :
  vim.api.nvim_create_autocmd( {"BufEnter"}, { pattern = "*.Jenkinsfile", callback = function () vim.opt_local.filetype = "groovy" end })

  -- les fichiers NOGIT_justfile sont à interpréter comme des justfiles :
  vim.api.nvim_create_autocmd( {"BufEnter"}, { pattern = "NOGIT_justfile", callback = function () vim.opt_local.filetype = "just" end })

  -- fichier de config typescript sont à interpréter en javascrip :
  vim.api.nvim_create_autocmd( {"BufEnter"}, { pattern = "tsconfig.json", callback = function () vim.opt_local.filetype = "javascript" end })

  -- folding json :
  local json_group = vim.api.nvim_create_augroup('json', { clear = false })
  vim.api.nvim_create_autocmd( {"FileType"}, { pattern = "json", group = 'json', callback = function () vim.opt_local.foldmethod = "syntax" end })

  -- folding avec les brackets triples {{{ }}} pour l'édition des fichiers vim (y compris le présent fichier) :
  local vim_group = vim.api.nvim_create_augroup('vim', { clear = true })
  vim.api.nvim_create_autocmd( {"FileType"}, { pattern = "vim", group = 'vim', callback = function ()
    vim.opt_local.foldmethod = "marker"
    vim.opt_local.foldlevel = 0  -- on veut les folds pliés quand on ouvre le fichier
  end })
end -- config_for_specific_files
config_for_specific_files()

-- Par défaut, on recherche 'tags' jusqu'à la racine :
vim.opt.tags="tags;/"

-- Augmenter la taille de la QuickfixList (et la réduire si inutile) :
-- cf. http://vim.wikia.com/wiki/Automatically_fitting_a_quickfix_window_height
vim.cmd([[
function! AdjustWindowHeight(minheight, maxheight)
  exe max([min([line("$"), a:maxheight]), a:minheight]) . "wincmd _"
endfunction
autocmd FileType qf call AdjustWindowHeight(3, 40)
]])

-- (CODE SETTINGS) }}}


--# PLUGINS {{{
--########################################################################################################################

-- lancement de lazy.nvim :
local lazypath = vim.fn.stdpath("data") .. "/lazy/lazy.nvim"
if not vim.loop.fs_stat(lazypath) then
  vim.fn.system({
    "git",
    "clone",
    "--filter=blob:none",
    "https://github.com/folke/lazy.nvim.git",
    "--branch=stable", -- latest stable release
    lazypath,
  })
end
vim.opt.rtp:prepend(lazypath)


local plugins = {
    {
        -- vim-outliner colors + foldings :
        "https://github.com/vimoutliner/vimoutliner.git",
        ft = 'votl',
    },
    -- file browser :
    {
        "https://github.com/nvim-tree/nvim-tree.lua",
        version = "*",
        lazy = false,
        dependencies = {
            "nvim-tree/nvim-web-devicons",
            },
        config = function()
            -- nvim-tree recommande de disabler netrw, cf. :help nvim-tree-netrw
            vim.g.loaded_netrw       = 1
            vim.g.loaded_netrwPlugin = 1

            require("nvim-tree").setup {
                actions = {
                    open_file = {
                        quit_on_open = true,
                    },
                },
                sort_by = "case_sensitive",
                view = {
                    width = 60,
                },
                renderer = {
                    group_empty = true,
                },
                filters = {
                    dotfiles = true,
                },
            }
            -- F8 = ouvrir nvim-tree sur le fichier courant :
            vim.keymap.set({'n', 'i', 'v'}, '<F8>', ':NvimTreeFindFileToggle<CR>', { noremap = true })

            -- S-F8 = ouvrir nvim-tree sur le git-root :
            -- attention, sous neovim, pour qu'un shortcut S-Fxx marche, il faut utiliser F(xx+12) :
            local function get_git_root()
                local dot_git_path = vim.fn.finddir(".git", ".;")
                return vim.fn.fnamemodify(dot_git_path, ":h")
            end
            vim.keymap.set({'n', 'i', 'v'}, '<F20>', ':NvimTreeToggle ' .. get_git_root() .. '<CR>', { noremap = true })
        end,
    },

    -- " fuzzy finder of... things (files, tags, LSP symbols, git commits, etc.)
    {
        'https://github.com/nvim-telescope/telescope.nvim',
        tag = '0.1.4',
        dependencies = { 'nvim-lua/plenary.nvim' },
        config= function()
          require('telescope').setup{
          defaults = {
            dynamic_preview_title = true,
          },
        }
        end,
    },

    -- enhances ga to display info on a character, including its digraph code
    {
        'https://github.com/tpope/vim-characterize'
    },

    -- ChatGPT :
    {
        "https://github.com/jackMort/ChatGPT.nvim",
        -- event = "VeryLazy",
        config = function()
            require("chatgpt").setup()
        end,
        cmd = {
            "ChatGPT",
            "ChatGPTActAs",
            "ChatGPTEditWithInstructions",
            "ChatGPTRun",
        },
        dependencies = {
            "MunifTanjim/nui.nvim",
            -- "nvim-lua/plenary.nvim",  -- already installed
            -- "nvim-telescope/telescope.nvim"  -- already installed
        }
    },

    -- align tokens of a line according to a separator :
    {
        "https://github.com/godlygeek/tabular.git",
        cmd = "Tabularize",
        init = function()
            -- Ctrl+T pour tabularize :
            vim.keymap.set({'v',}, '<C-T>', ':Tabularize /', { noremap = true })
        end,
    },

    -- surround :
    {
        "https://github.com/tpope/vim-surround.git",
    },

    -- repeat a surrounding command
    {
        "https://github.com/tpope/vim-repeat",
    },

    -- comment :
    {
        'https://github.com/numToStr/Comment.nvim',
        config = function()
            require('Comment').setup()
        end,
    },

    -- language pack :
    {
        'https://github.com/sheerun/vim-polyglot',
        init = function()
            -- disabling polyglot ftdetect, in order for OTL files to properly be detected :
            -- also disabling it for markdown (I cannot get polyglot's markdown to work with
            -- vim-markdown-folding, and I value markdown folding more than markdown
            -- highlighting...) :
            vim.g.polyglot_disabled = {'ftdetect', 'markdown'}  -- must be set BEFORE polyglot is loaded
        end,
    },

    -- visualiser les indentations :
    {
        "https://github.com/lukas-reineke/indent-blankline.nvim",
        main = "ibl",
        opts = {},
        config = function()
            vim.cmd.highlight({"IndentLine", "ctermfg=grey"})
            require("ibl").setup {
                indent = { highlight = { "IndentLine" } },
                whitespace = { highlight = { "Normal" } },
            }
        end,
    },

    -- markdown-folding :
    {
        "https://github.com/masukomi/vim-markdown-folding",
        config = function()
            -- for vim-markdown-plugin : folding a level 1 title should also fold all its children :
            vim.api.nvim_create_autocmd({"FileType"}, {
                pattern = "markdown",
                callback = function (opts)
                    -- see https://neovim.io/doc/user/lua-guide.html#_-vim.opt
                    -- vim.opt: behaves like :set
                    vim.opt.foldexpr = "NestedMarkdownFolds()"
                end,
            })
        end,
    },

    -- make searched line pulse briefly to ease visualization
    {
        "https://github.com/inside/vim-search-pulse",
        config = function()
            -- strict équivalent de :  let g:vim_search_pulse_color_list = [22, 28, 34, 40, 46]
            vim.g.vim_search_pulse_color_list = {22, 28, 34, 40, 46}
        end,
    },

    -- smooth scrolling (to ease visualizing Ctrl-down/Ctrl-up)
    {
        "karb94/neoscroll.nvim",
      config = function ()
          require('neoscroll').setup {}
      end
    },

    -- nvim LSP config :
    {
        "https://github.com/neovim/nvim-lspconfig",
    },

    -- running generic tools as LSP servers
    {
        "https://github.com/jose-elias-alvarez/null-ls.nvim",
    },

    -- rust-tools :
    {
        "https://github.com/simrat39/rust-tools.nvim",
    },


    -- highlight same words as the one under cursor
    -- note : pour visualiser dynamiquement les highlights groups :
    --   :so $VIMRUNTIME/syntax/hitest.vim
    {
        'https://github.com/tzachar/local-highlight.nvim',
        config = function()
            require('local-highlight').setup({
                file_types = {'python', 'cpp', 'rust'},
                hlgroup = 'CursorColumn',
                insert_mode = false,
            })
        end
    },

    -- auto cd to git root dir :
    {
        "https://github.com/ahmedkhalf/project.nvim",
        config = function()
            require('project_nvim').setup {}
        end,
    },

    -- justfile syntax
    {
        "https://github.com/NoahTheDuke/vim-just",
    },

    -- debugger = DAP-client :
    {
        "https://github.com/puremourning/vimspector",
        config = function()
            -- démarrer / arrêter le débugging d'un programme :
            vim.keymap.set('n', '<leader><F5>', '<Plug>VimspectorContinue', { noremap = true })
            vim.keymap.set('n', '<leader><F3>', '<Plug>VimspectorStop', { noremap = true })
            vim.keymap.set('n', '<leader><F4>', '<Plug>VimspectorRestart', { noremap = true })
            vim.keymap.set('n', '<leader><F6>', '<Plug>VimspectorPause', { noremap = true })
            vim.keymap.set('n', '<leader><F9>', '<Plug>VimspectorToggleBreakpoint', { noremap = true })
            vim.keymap.set('n', '<leader><F8>', '<Plug>VimspectorRunToCursor', { noremap = true })
            -- piloter l'avancée du programme en cours d'exécution :
            vim.keymap.set('n', 'gn', '<Plug>VimspectorStepOver', { noremap = true })
            vim.keymap.set('n', 'gs', '<Plug>VimspectorStepInto', { noremap = true })
            vim.keymap.set('n', 'go', '<Plug>VimspectorStepOut', { noremap = true })
            -- fermer la fenêtre vimspector :
            vim.keymap.set('n', '<leader>q', ':VimspectorReset<CR>', { noremap = true })
        end,
    },
}

require("lazy").setup(plugins, opts)

-- (PLUGINS) }}}


--# LSP-RELATED {{{
--########################################################################################################################

-- See `:help vim.diagnostic.*` for documentation on any of the below functions


-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
local on_lsp_attach = function(client, bufnr)

  -- weirdly, lsp highlights overwrite polyglot (and are awful), better to disable them :
  -- see https://neovim.io/doc/user/lsp.html#lsp-semantic-highlight
  -- see https://gist.github.com/swarn/fb37d9eefe1bc616c2a7e476c0bc0316
  for _, group in ipairs(vim.fn.getcompletion("@lsp", "highlight")) do
    vim.api.nvim_set_hl(0, group, {})
  end

  -- Enable completion triggered by <c-x><c-o> :
  vim.api.nvim_buf_set_option(bufnr, 'omnifunc', 'v:lua.vim.lsp.omnifunc')
  -- fermer la preview window une fois qu'on a choisi l'automplétion :
  vim.api.nvim_create_autocmd({"CompleteDone"}, { callback = function() vim.cmd.pclose() end})

  -- Mappings.
  -- See `:help vim.lsp.*` for documentation on any of the below functions
  local bufopts = { noremap=true, silent=true, buffer=bufnr }

  -- naviguer entre les erreurs LSP :
  vim.keymap.set('n', '<A-k>', vim.diagnostic.goto_prev, { noremap=true, silent=true})
  vim.keymap.set('n', '<A-j>', vim.diagnostic.goto_next, { noremap=true, silent=true})

  -- native LSP-client :
  vim.keymap.set({'n', 'i', 'v'}, '<F12>', vim.lsp.buf.definition, bufopts)  -- F12 = go to definition in the same tab
  vim.keymap.set({'n', 'i', 'v'}, 'g<F12>', '<ESC><cmd>tab split<CR><cmd>lua vim.lsp.buf.definition()<CR>', bufopts)  -- g-F12 = go to definition in a new tab
  vim.keymap.set({'n', 'v'}, 'gh', vim.lsp.buf.hover, bufopts)
  vim.keymap.set({'n', 'v'}, 'gb', vim.lsp.buf.code_action, bufopts)  -- "gb" car le C (pour [C]ode-actions) et le A (pour code-[A]ctions) sont déjà pris...
  vim.keymap.set('n', '==', vim.lsp.buf.format, bufopts)
  vim.keymap.set('v', '=', vim.lsp.buf.format, bufopts)  -- range format

  -- telescope + LSP = <3
  -- vscode shortcut to search symbols is C-t ; as it's not available in vim, I use C-A-t :
  vim.keymap.set({'n', 'i', 'v'}, '<C-A-t>', require('telescope.builtin').lsp_dynamic_workspace_symbols, bufopts)
  -- https://code.visualstudio.com/docs/editor/codebasics#_search-across-files
  -- vscode shortcut to search text is C-S-f ; as it's not available in vim, I use C-A-g :
  vim.keymap.set({'n', 'i', 'v'}, '<C-A-g>', require('telescope.builtin').live_grep, bufopts)
  -- to make S-Fxx work in neovim, I have to use Fyy where yy = xx + 12 :
  vim.keymap.set({'n', 'i', 'v'}, '<F24>', function() require('telescope.builtin').lsp_references({path_display={"tail"}}) end, bufopts)  -- S-F12 = who uses this symbol ?


  -- NdM : rename = besoin suffisamment rare pour ne pas ajouter de mapping :
  -- un alias me permet de compléter la commande plus facilement (il va demander le nouveau nom) :
  --
  --      :lua lsp_rename()
  --
  -- attention : des buffers peuvent être modifiés par le renommage sans être directement visibles !
  -- contournement 1 = les consulter (:Telescope buffers)
  -- contournement 2 = tout enregistrer avec :wa (= :writeall)
  lsp_rename = vim.lsp.buf.rename

  -- NdM : moins utile que 'definition' :
  -- vim.keymap.set({'n', 'i', 'v'}, '<F12>', vim.lsp.buf.declaration, bufopts)

  -- NdM : non-pris en charge par clangd et/ou pyright :
  -- vim.keymap.set({'n', 'i', 'v'}, '<F12>', vim.lsp.buf.type_definition, bufopts)
  -- vim.keymap.set({'n', 'i', 'v'}, '<F12>', vim.lsp.buf.implementation, bufopts)

  -- toggling diagnostics (there is no native function for that) :
  -- inspired by https://www.reddit.com/r/neovim/comments/ng0dj0/lsp_diagnostics_query_is_there_an_way_to_toggle/
  vim.g.diagnostics_active = true
  function _G.toggle_diagnostics()
    if vim.g.diagnostics_active then
      print('disabling diagnostics...')
      vim.g.diagnostics_active = false
      vim.diagnostic.disable()
    else
      print('enabling diagnostics...')
      vim.g.diagnostics_active = true
      vim.diagnostic.enable()
    end
  end
  -- gt sert normalement à switcher de tab, mais je n'utilise pas -> g[T]oggle :
  vim.keymap.set({'n', 'v'}, 'gt', _G.toggle_diagnostics, bufopts)

  -- Je préfère ces couleurs pour les diagnostics LSP :
  -- :hi pour voir les highlights actuels (avec exemples)
  -- pour info, valeurs par défaut :
  -- DiagnosticError xxx ctermfg=1 guifg=Red
  -- DiagnosticWarn xxx ctermfg=3 guifg=Orange
  -- DiagnosticInfo xxx ctermfg=4 guifg=LightBlue
  -- DiagnosticHint xxx ctermfg=7 guifg=LightGrey
  -- NDM : vim.cmd() permet de passer des commandes vimscript
  vim.cmd("hi DiagnosticError cterm=underline,bold ctermfg=1 gui=bold guifg=Red")
  vim.cmd("hi DiagnosticWarn  cterm=underline,bold ctermfg=3 gui=bold guifg=Orange")
  vim.cmd("hi DiagnosticInfo  cterm=underline,bold ctermfg=4 gui=bold guifg=LightBlue")
  vim.cmd("hi DiagnosticHint  cterm=underline,bold ctermfg=0 gui=bold guifg=Black")
end  -- on_lsp_attach

require('lspconfig')['pyright'].setup{
    on_attach = on_lsp_attach,
    flags = lsp_flags,
}
require('lspconfig')['clangd'].setup{
    on_attach = on_lsp_attach,
    flags = lsp_flags,
}
require('lspconfig')['tsserver'].setup{
    on_attach = on_lsp_attach,
    flags = lsp_flags,
}
require('rust-tools').setup{
    server = {on_attach = on_lsp_attach},
    flags = lsp_flags,
    tools = {inlay_hints = {
        max_len_align = true,
        highlight= "RustToolsTypeInfo",
        }
    },
}

-- null-lsp :
local null_ls = require("null-ls")
local sources = {
    null_ls.builtins.diagnostics.flake8.with({extra_args = {"--max-line-length","120"}}),
}
null_ls.setup({ sources = sources })


-- always show error columns :
vim.api.nvim_set_option('signcolumn', 'auto:1-3')
vim.cmd.highlight({"SignColumn", "ctermbg=Grey"})


-- use of telescope for non-LSP things :
local telescope_non_lsp = function()
  -- parcourir l'aide vim avec telescope (Ctrl+T pour ouvrir l'aide dans un nouveau tab)
  vim.keymap.set({'n', 'i', 'v'}, '<C-h>', require('telescope.builtin').help_tags, { noremap = true })

  -- visualiser les buffers (:help buffers pour avoir la signification des caractères) :
  vim.keymap.set({'n', 'i', 'v'}, '<C-b>', function() require('telescope.builtin').buffers() end, { noremap = true })

  -- Ctrl+p already use in vscode : https://linuxpip.org/vscode-find-file/
  vim.keymap.set({'n', 'i', 'v'}, '<C-p>', function() require('telescope.builtin').find_files({path_display={"truncate"}}) end, { noremap = true })
end  -- telescope_non_lsp
telescope_non_lsp()


-- (LSP-RELATED) }}}


--# MY CHEATSHEET {{{
--########################################################################################################################

-- FIXME : ceci pourrait plutôt être un fichier OTL, et la fonction se contenterait de le charger dans un tab
--         (un OTL sera plus facile à écrire, maintenir et même consulter)
function display_mycheatsheet_in_tab()
    local mycheatsheet_str = [=[
Pour afficher cette cheatsheet :   :Cheat  /  :call CheatsheetFunction()
 
Pour grepper l'help avec telescope : CTRL+h  /  :Telescope help_tags
 
======= SEARCH :
    :copen / :ccl[ose]     ouvrir / fermer la quickfix list
    F8                     ouvrir nvim-tree sur le répertoire courant
    S-F8                   ouvrir nvim-tree sur le git-root
      ├─ g?                 afficher les commandes
      ├─ q                  fermer nvim-tree
      ├─ Entrée             ouvrir le fichier sélectionné dans le buffer courant
      ├─ C-t / C-x / C-h    ouvrir le fichier sélectionné dans un nouveau tab / vsplit / hsplit
      ├─ o                  ouvrir/fermer un répertoire
      ├─ H                  toggle l'affichage des fichiers cachés
      ├─ a / r / d          ajouter / renommer / supprimer un fichier
      ├─ y  /  gy           copier le nom / le chemin complet du fichier
      └─ -  /  P            remonter d'un cran dans la hiérarchie / se déplacer sur le répertoire parent
 
======= LAZY.NVIM :
    https://github.com/folke/lazy.nvim
      └─ :Lazy check        afficher l'UI de gestion de lazy.nvim (qui donne accès à toutes les commandes)
 
======= DEV :
    CTRL-o / CTRL-i        jumper à un emplacement précédent / suivant du curseur
    :help tags
      ├─build tags :
      │   apt install exuberant-ctags
      │   ctags --recurse --c++-kinds=+p --fields=+iaS --extras=+q .
      ├─CTRL+]              jumper à la définition du tag
      ├─CTRL+t              revenir à l'emplacement précédent
      ├─g puis CTRL+]       choisir la destination du jump dans une liste
      └─vim -t pouet        ouvrim vim sur le fichier + à l'emplacement du tag 'pouet'
    LSP
      ├─ F12                 go to definition
      ├─ Shift+F12           see references
      ├─ gh                  infos sur le symbole courant dans une bulle hover
      ├─ Alt+j / Alt+k       go to next/previous error
      ├─ :LspStop/Start      (dés)activer le LSP client (semble mal marcher avec null-ls...)
      ├─ :LspInfo            des infos sur la config des LSP (e.g. quels linters sont actifs)
      ├─ gt                  toggle les diagnostics LSP
      └─ CTRL+x CTRL+o       complétion intelligente respectant le contexte via LSP
    CTRL+n                 complétion 'dumb'
    Telescope
      ├─ CTRL-n / CTRL-p     naviguer dans les matchs en mode insertion
      ├─ Entrée / CTRL-t     ouvrir le match dans l'onglet courant / un nouvel onglet
      ├─ CTRL+/  ou  ?       aide sur les shortcuts de telescope (insert-mode ou normal-mode)
      ├─ CTRL+ALT+g          live_grep dans le répertoire courant
      ├─ CTRL+ALT+t          rechercher des noms de symboles dans l'index LSP
      └─ CTRL+p              fuzzy search files by name (telescope)
    Alt-o                  alterner entre .h / .cpp
    :AT                    alterner entre .h / .cpp dans un nouvel onglet
    CTRL-y + ,             lancer emmet (pour tags HTML faciles)
    CTRL-t + <sep>         (visual) tabularize avec des colonnes séparées par <sep>
    :IndentLinesToggle     toggle le marqueur des indentations python
    :gJ  /  gS             split/join les arguments d'une fonction, placer curseur sur parenthèse ouvrante
    == / (visual)=         reformatter tout le fichier (ou uniquement la sélection visuelle)
 
======= MES ALIAS PERSOS (hors plugins) :
    CTRL-HAUT/BAS          scroller une ligne vers le bas/haut
    ALT-DROITE/GAUCHE      :tabNext / :tabPrev  (EDIT : également commandes natives : gt/gT)
    ççh                    toggle hlsearch
    ççi                    toggle ignorecase
    ççn                    toggle line numbers
    ççsyntax               refresh la syntaxe
    |                      ouvrir le tag dans un onglet (ou sinon : C-w + C-]  puis C-w + S-T)
 
======= OTHER CORE VIM FEATURES :
    :help fold
      ├─:set foldlevel=3    setter le foldlevel
      ├─zO / zC             ouvrir/fermer le fold actuel et tous ses fils
      ├─zr / zm             ouvrir/fermer un niveau de fold supplémentaire
      └─zR / zM             ouvrir/fermer TOUS les folds du fichier (utile dans vimdiff)
    vimdiff file1 file2
      ├─dp                  [P]ut the diff to other file
      ├─do                  [O]btain the diff from other file
      ├─:diffupdate         refresh diff
      ├─CTRL-w + w          mettre le curseur sur l'autre fichier
      └─zR / zM             afficher/masquer les portions identiques du fichier
    :help split
      ├─CTRL-w + _          maximiser le split courant
      ├─CTRL-w + =          égaliser les splits
      ├─:res[ize] 15        setter la taille du split à 15
      ├─:res[ize] +3        augmenter la taille du split de 3 (également CTRL-w - 3+)
      ├─CTRL-w + w          déplacer le focus sur un autre split
      └─CTRL-w + CTRL-r     swapper les splits
    :help C-r
      ├─CTRL-r + REG        insère le contenu du registre REG (\" pour le registre anonyme)
      ├─CTRL-r + /          insère le pattern de recherche
      └─CTRL-r + CTRL-w     insère le mot sous le curseur
    :norm! @a              applique la macro 'a' (à utiliser sur un groupe de lignes)
    :set conceallevel=0    ne pas masquer de texte (e.g. markdown)
    :echo mapleader        afficher le <leader> actuel
    :map STRING            afficher les mappings commençant par STRING -> doc de mes raccourcis !
    :map <leader>          afficher les mappings commençant par <leader> (marche aussi avec p.ex. <F5>)
    ma / 'a                définir la / sauter vers la marque <a>
    ''                     après avoir sauté vers une marque, '' permet de revenir là où on était
 
    ... to be continued ...
]=]
    vim.cmd("tabnew MYCHEATSHEET")

    -- convert single string into table of lines :
    local lines = {}
    for s in mycheatsheet_str:gmatch("[^\r\n]+") do
        table.insert(lines, s)
    end

    vim.fn.append(0, lines)
    vim.fn.cursor(1, 1)
end

-- how to display my sheatsheet :
vim.api.nvim_create_user_command('Cheat', display_mycheatsheet_in_tab, {})
vim.api.nvim_create_user_command('Cheatsheet', display_mycheatsheet_in_tab, {})

-- (MY CHEATSHEET) }}}

EOF
endif  " has("nvim")
